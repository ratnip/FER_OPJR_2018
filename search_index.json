[
["index.html", "Programirajmo u R-u (Udžbenik za vještinu “Osnove programskog jezika R”) Predgovor", " Programirajmo u R-u Damir Pintar 2018-10-30 (Udžbenik za vještinu “Osnove programskog jezika R”) ** NAPOMENA: Za vrijeme odvijanja vještine “Osnove programskog jezika R” u tekućoj akademskoj godini provodi se revizija poglavlja udžbenika. Nakon što se materija odradi na predavanjima te završi ciklus predaje radnih bilježnica nova poglavlja će se dinamički dodavati u ovaj HTML dokument. Ukoliko vam je nužno potreban pristup cjelokupnim materijalima kontaktirajte autora udžbenika na damir.pintar@fer.hr ** Predgovor Ovaj udžbenik nastao je iz interaktivnih lekcija korištenih na vještini “Osnove programskog jezika R” na Fakultetu elektrotehnike i računarstva Sveučilišta u Zagrebu. No teme koje se ovdje obrađuju nisu korisne samo studentima navedenog fakulteta - poznavanje jezika R dobro će doći kako u akademskom, tako i u poslovnom svijetu. Iako je R poznat kao “programski jezik napravljen od statističara, za statističare” te se najčešće povezuje sa poljem podatkovne znanosti unutar kojeg se koristi za složene statističke i dubinske analize, on se može pokazati vrlo koristan i za poslove vezane uz upravljanje manjim ili većim podatkovnim skupovima koji nisu nužno strogo orijentirani naprednoj analitici. Naime, popularni grafički alati sa svojim interaktivnim tabličnim prikazom vrlo su intuitivni i odlični za jednostavnije poslove, no kako se pojavljuju potrebe za složenijim zadacima oni vrlo brzo gube na učinkovitosti i jednostavnosti; s druge strane, interaktivni programski pristup kojeg nudi R inicijalno je nešto zahtjevniji, no dugoročno vrlo isplativ jer se i vrlo složeni zadaci mogu rješavati na učinkovit, konzistentan i pregledan način. Upravo iz tog razloga u poslovnom svijetu pojavljuje se jasna tendencija odmaka od klasičnih grafičkih alata prema platformama sa boljom podrškom za provođenje složenijih izračuna i stvaranje atraktivnih vizualizacija. Ovo se očituje snažnim porastom popularnosti jezika R i drugih platformi sa sličnim pristupom analizi podataka. Navedena popularnost jezika R rezultira i povećanom potrebom za resursima za učenje, kojih na hrvatskom jeziku trenutno nema baš previše. Ovaj udžbenik svojim pristupom “učenja kroz primjere” pokušati će učenje R-a učiniti što lakšim i zanimljivijim. Naglasak će biti stavljen prvenstveno na svladavanje R-a kao programskog jezika. Upravo zbog toga početna poglavlja baviti će se poglavito “programerskim aspektima”, a potom će biti dan pregled dostupnih alata za zadatke za koje pretpostavlja da su korisni najširem skupu čitatelja - upravljanje podatkovnim skupovima, izvlačenje korisnih informacija i stvaranje vizualizacija. Budući da je R ipak domenski orijentirani jezik, priča o R-u zaokružiti će se kratkim uvidom u njegovu podršku za statističke analize te pregledom odabranih metoda strojnog učenja i njihove primjene. Iako će biti dano dovoljno informacija da se sve prikazane metode stave u kontekst, ideja ovog udžbenika nije naučiti čitatelja statistiku niti duboko ući u polje strojnog učenja - namjera autora jest zaintrigirati čitatelja da nastavi istraživanje ovog interesantnog područja, adekvatno naoružanog znanjem platforme koje će omogućiti da sva novousvojena znanja odmah praktično primjeni u svojim daljnjim istraživanjima. "],
["uvod.html", "1 Uvod 1.1 Što je programski jezik R? 1.2 Instalacija programske podrške 1.3 Pregled razvojnog sučelja RStudio 1.4 Kako koristiti ovaj udžbenik?", " 1 Uvod 1.1 Što je programski jezik R? 1.1.1 Općenito o R-u Programski jezik R proizašao je iz programskog jezika S, razvijenog za potrebe Bell Telephone Laboratorija u vlasništvu AT &amp; T korporacije. Zamišljen je kao interni alat za statističku analizu. Osnovna filozofija jezika S (koju je naslijedio i programski jezik R) bila je domenska orijentiranost - tj. olakšavanje posla podatkovnim analitičarima bez potrebe za prilagođavanjem konvencijama tradicionalnih programskih jezika. Jezik S je kroz 80.-te i 90.-te dosegnuo značajnu popularnost u krugovima poslovnih analitičara i statističara, no dostupan samo kroz komercijalnu varijantu nazvanoj S-PLUS. Programski jezik R nastao je na sveučilištu u Aucklandu (NZ) po uzoru na S, a 2000. objavljuje se pod GNU licencom otvorenog koda. Standardna distribucija R programskog jezika sastoji se od: “jezgre” R-a, sa temeljnim funkcijama i tzv. base paketom koji omogućuje osnovnu funkcionalnost kolekcijom dodatnih paketa (“osnovni” - base i “preporučeni” - recommended) za upravljanje podacima, vizualizacije i statističke analize Ovdje ne treba zanemariti izvrsnu integraciju R-a sa bogatim repozitorijem paketa zvanom CRAN (Coprehensive R Archive Network) koja omogućuje brzu i jednostavnu instalaciju bilo kojeg paketa iz navedenog repozitorija nakon čega on postaje dio lokalne R instalacije. Budući da je za jezik R specifičan iznimno jaki utjecaj R zajednice na razvoj novih paketa, često se nakon pojavljivanja novih eksperimentalnih metoda i pristupa podatkovne analize vrlo brzo na CRAN-u mogu pronaći paketi koji iste implementiraju, a također treba spomenuti i snažni i kontinuirani entuzijazam R zajednice za razvoj poboljšanja postojećih elemenata R-a koji ublažavaju ili uklanjaju veliki broj uočenih manjkavosti jezika. R se zbog toga često zna uspoređivati sa “uradi sam” projektom gdje korisnik, nakon upoznavanja sa isporučenim “tvorničkim” komponentama (u ovom slučaju temeljnim funkcijama i paketima), počinje prilagođavati svoju razvojnu okolinu odabirom paketa koji točno odgovaraju njegovim potrebama i preferencama. Kreativnost i fleksibilnost u korištenju R-a se smatra njegovom velikom prednošću, iako rezultira određenom neformalnošću i liberalnim pristupom programiranju koji nije omiljen korisnicima naviknutim na stroge i formalne programske okvire sa jasnim skupom smjernica i pravila koja se moraju slijediti. Usprkos iznimno velikoj prihvaćenosti jezika R za podatkovne analize te mnoštvu opcija koje nudi korisniku, potrebno je odmah u početku biti svjestan i njegovih određenih ograničenja: R jako intenzivno koristi radnu memoriju što je dugo vremena smatrano ozbiljnim ograničenjem; porastom kapaciteta modernih hardverskih sustava ovo ograničenje je danas puno prihvatljivije, a također su se pojavili brojni paketi koji racionaliziraju korištenje memorije. Ipak ostaje činjenica da R brzo “pojede” RAM našeg računala, iako je to često i rezultat nepažnje ili neznanja programera koji nije dovoljno dobro usvojio “R-ovski” način programiranja. R je prilično nekonvencionalan tako da je krivulja učenja inicijalno nešto strmija, pogotovo za programere naviknute na standardne konvencije drugih programskih jezika. S druge strane, ako se gleda dugoročno, programiranje u R-u je prilično jednostavno budući da je većina kompleksnih zadataka apstrahirana u visokorazinske funkcije koje transparentno obavljaju operativne poslove niske razine. Često se kaže da je R više orijentiran cilju kojeg želimo postići a manje detaljima oko puta kojim do njega stižemo. R nije “brzi” jezik; iako se radi o jeziku koji očekivano radi nad velikim skupovima podataka, R nije optimiziran za brzinu izvođenja, pa čak ni za višedretvenost; iako je veliki trud uložen da se gotovo sve ključne rutine implementiraju u C-u i da se spriječe znatna usporavanja, a postoji i niz paketa koji omogućuju višedretveno izvođenje R programa, i dalje stoji činjenica da R nije dizajniran s ciljem da se izvršava što je brže moguće; ukoliko je brzina prioritet, često je potrebno tražiti alternativna rješenja - zbog čega se često zna reći da je R primarno istraživački jezik, ne produkcijski. R je prvenstveno namijenjen za interaktivni rad, tj. izvođenje niza strojnih instrukcija koje se dinamički upisuju i izvode uz pomoć programske konzole. Ovo je prilagođeno standardnom procesu analize podataka gdje analitičar može učitavati podatke, čistiti ih, transformirati, razvijati modele, testirati i sl. uz konstantnu povratnu informaciju od računala, mogućnost pregleda međurezultata, izmjene procesa prema trenutnim saznanjima i sl. Ovo ne znači da se u programskom jeziku ne može programirati na klasičan “proceduralni” način, razvojem algoritama enkapsuliranih u funkcije koje onda nakon pozivanja automatski obavljaju svoje zadatke, ali činjenica jest da se učinkovitost R-a upravo odražava u interaktivnom radu. Ovaj princip se prenosi i na učenje R-a; programski jezik R puno se lakše uči interaktivnim pristupom uz izvršavanje konkretnih zadataka, eksperimentiranjem s podatkovnim skupovima, dostupnim metodama i sl. nego “klasičnim” pristupom izrade programskih skripti koje implementiraju neke niskorazinske poslove. 1.1.2 Alternative jeziku R Programski jezik R je popularno, ali ne i jedino rješenje za interaktivnu analizu podataka i statističko programiranje. U nastavku ćemo dati kratki pregled nekih popularnijih tehnologija i rješenja koje se danas koriste u ovu svrhu, uz kratku usporedbu i osvrt na prednosti i nedostatke u usporedbi sa onim što nudi jezik R. SAS i SPSS – SAS (Statistical Analysis System, razvijen od strane SAS Institute) i SPSS (Software Package for Statistical Analysis, razvijen od strane IBM-a) su dva različita softverska paketa koje stavljamo pod istu stavku prvenstveno zato što se radi o komercijalnim alatima, tj. alatima koji za svoju punu funkcionalnost zahtijevaju plaćanje licence. Isto tako, SAS i SPSS se relativno lako uče a svoju funkcionalnost u velikoj mjeri zasnivaju na pomno dizajniranim korisničkim sučeljima. Ovi alati naglasak stavljaju na učinkovitost i odlična su opcija za velike tvrtke koje traže konzistentno, robusno rješenje za svoju analitiku i kojima ne smeta komercijalna priroda takvih rješenja. Weka i Orange – Weka (Waikato Environment for Knowledge Analysis, razvijen od strane sveučilišta Waikato na Novom Zelandu) i Orange (alat za dubinsku analizu podataka razvijen na sveučilištu u Ljubljani) su besplatan softver za eksploratornu analizu podataka i dubinsku analizu koji svoju funkcionalnost zasnivaju na relativno jednostavnim grafičkim sučeljima i vizualnom pristupu programiranju. Ova rješenja vrlo su dobra za korisnike koji nisu previše zahtjevni glede fleksibilnosti i kompleksnosti svojih analiza jer na vrlo pristupačan i jasan način omogućuju provedbu definiranih koraka procesa analize. To ne znači da se u ovim alatima ne mogu raditi i kompleksnije analize, samo da su oni ipak prilagođeniji analizama kroz predefinirane funkcionalnosti pruženog grafičkog sučelja. Python (Numpy / Pandas / Scikit) – u zadnjih nekoliko godina upravo je Python najozbiljniji konkurent jeziku R, prvenstveno zbog činjenice da je Python sam po sebi vrlo popularan programski jezik koji za potrebe analize podataka koristi pakete s vrlo sličnim pristupom procesu analize onom kojeg koristi i jezik R. Rasprava o tome koji jezik odabrati je vrlo česta u polju znanosti o podacima, obično bez jasnog konačnog zaključka. Lako s uvjeriti da su razlike zapravo u nijansama - dok je R snažno domenski orijentiran i veći naglasak stavlja na lakoću i jednostavnost korištenja uz široku paletu dostupnih paketa sa preklapajućim funkcionalnostima kako bi korisnik mogao odabrati onaj koji mu najviše odgovara, Python naglašava rigidnu formalnu strukturu i princip “za jedan posao jedan način obavljanja”. Stoga bi se moglo reći da je R nešto pogodniji za “istraživanje podataka” dok je prednost Pythona lakši razvoj i integracija analitičkih modula u nekom produkcijskom okruženju, pogotovo ako je navedeno okruženje već izvedeno u Pythonu. No snažnim razvojem oba jezika i međusobnim praćenjem funkcionalnosti i ova navedena razlika postaje sve manje relevantna - danas više nije problem integrirati R skripte u postojeće sustave neovisno o platformi na kojoj su izvedeni, a u Python zajednica razvija svoje inačice popularnih paketa iz R-a koje vjerno preslikavaju njihovu funkcionalnost. U konačnici se može reći da inicijalni odabir između ove dvije alternative i nije toliko bitan - pristup kojeg koriste je toliko sličan a praćenje funkcionalnosti toliko izraženo da se učenjem jednog jezika svladava većina bitnih koncepata iz drugog tako da se podatkovni znanstvenici često na kraju odlučuju na svladavanje oba jezika, kako bi se lako prilagodili velikom broju okruženja u kojima moraju provoditi svoje analize. 1.2 Instalacija programske podrške Instalacija programske podrške za jezik R je prilično jednostavna, pogotovo ako se kao platforma koristi preporučeno razvojno sučelje RStudio. Ovo nije jedina opcija - jedna od popularnih alternativa jest i višejezična platforma Jupyter Notebook koja nudi vlastitu podršku za R. Čitateljima se dugoročno preporučuje istraživanje svih dostupnih opcija i konačni odabir onog sučelja koje osobno procijene najboljim za svoje potrebe, no ovaj udžbenik će se usredotočiti na RStudio ponajviše zbog jasnog, preglednog sučelja, lake instalacije i vrlo bogate podrške za različite funkcionalnosti - od instalacije novih paketa, lakog dohvaćanja dokumentacije, prikaza vizualizacija do stvaranja i objave izvještaja. Radne bilježnice o kojima će više riječi biti u nastavku uglavnom pretpostavljaju da ste odabrali sučelje RStudio. Za uspješno postavljanje razvojne platforme potrebno je instalirati dvije stvari distribuciju jezika R razvojno sučelje RStudio Preporučuje se koristiti najnovije dostupne inačice. U trenutku pisanja ovog dokumenta to su R 3.3.2 i RStudio 1.0.136. Ukoliko se ove inačice razlikuju od one koje se nalaze na vašem računalu, vjerojatno neće biti problema ukoliko su brojevi inačica viši od navedenih; u suprotnom preporučuje se njihova nadogradnja. U nastavku će se opisati postupak za instalaciju navedenog softvera na operacijski sustav Microsoft Windows. Ukoliko radite na nekom od drugih operacijskih sustava, kao što je neka od Linux distribucija ili Mac OS procedura je nešto drugačija, no i dalje ne previše složena - dovoljno je pratiti upute na web stranicama spomenutim u nastavku koje su orijentirane platformi koju koristite. Kako bi pronašli spomenuti softver u tražilicu upišite sljedeće pojmove: download R download RStudio U oba slučaja dobiti ćete stranice sa poveznicama na izvršne datoteke koje morate pokrenuti kako bi se softver instalirao na vaše računalo. U slučaju jezika R to može biti datoteka R-3.3.2-win.exe (točni brojevi se mogu razlikovati). Kod sučelja RStudio možete vidjeti više opcija - odaberite besplatnu “desktop” inačicu. Komercijalne inačice imaju neke dodatne funkcionalnosti koje su većinom orijentirane uporabi u profesionalnim, višekorisničkim okruženjima te nisu bitne za uobičajeni rad. Izvršne datoteke možete pokrenuti i pustiti čarobnjaka da instalira sve potrebne komponente na vaše računalo. Preporučuje se prihvatiti sve nazivne opcije osim mape instalacije - umjesto podmape “Program Files” bolje je instalirati R direktno u osnovnu mapu (npr. “C:\\R\\R-3.3.2”). Na ovaj način biti će lakše pronaći trenutno instaliranu inačicu i eventualno kasnije ažurirati. Iz istih razloga preporučuje se RStudio instalirati u mapu “C:\\R\\RStudio”. U slučaju da niste mogućnosti ili ne želite odabrati ove mape, možete definirati neke druge ili zadržati nazivne opcije - ovaj izbor ne bi u konačnici trebao bitno utjecati na daljnji rad. Nakon instalacije sučelja RStudio dovoljno je isto jednostavno pokrenuti uz pomoć stvorene kratice na radnoj mapi (ili alternativno, uz pomoć izvršne datoteke RStudio.exe u odabranoj mapi za instalaciju). Nakon pokretanja aplikacija bi trebala izgledati slično sljedećoj slici: Slika 1.1: Izgled sučelja RStudio Ukoliko je došlo do nekih problema, provjerite da li ste ispravno proveli sve navedene korake instalacije. U nastavku ćemo se pozabaviti detaljima prikazanog sučelja. 1.3 Pregled razvojnog sučelja RStudio Pogledajmo sučelje RStudio. Vidimo da je podijeljeno na tri prozora - lijevi dio je “radni” i u njega upisujemo programski kod. S desne strane se nalaze pomoćni prozori koji prikazuju različite stvari, ovisno o odabranoj kartici; u gornjem desnom dijelu između ostalog možemo vidjeti što se trenutno nalazi u našoj radnoj okolini (koja je na početku prazna) te povijest naredbi koje smo izvršavali. Donji dio služi za prikaz dokumentacije, datoteka u radnoj mapi, instaliranih paketa, vizualizacija i sl. 1.3.1 Interaktivna konzola Vratimo se na lijevi dio sučelja. Ovdje se zapravo radi o tzv. “interaktivnoj konzoli”. Naime, po svojoj prirodi R je tzv. “interpreterski jezik” u smislu da se naredbe odmah interpretiraju i izvršavaju. Iako je moguće izrađivati i veće skripte koje se onda izvršavaju “u komadu”, rad sa jezikom R vrlo često se svodi na princip naredba - odgovor. Upravo zbog toga govorimo o “interaktivnoj programskoj analizi podataka” - analitičar “programira” upisivanjem naredbi te u svakom trenutku može proučiti dobivene međurezultate i odlučiti se na daljnje korake. Prikažimo kako radi interaktivna konzola. Uz pomoć tipkovnice možemo utipkati jednostavan matematički izraz - npr. 3 + 2 i stisnuti tipku ENTER. Vidimo da će nam R odmah pružiti rezultat - možemo ga koristiti i kao kalkulator! Za matematičke izraze koje nije jednostavno “utipkati” moramo koristiti funkcije. Tako npr. drugi korijen možemo izračunati uz pomoć funkcije sqrt(). Pokušajmo u konzolu utipkati sqrt(10) i stisnuti ENTER. R nam opet odmah prikazuje rezultat. U ovom trenutku zaslon bi nam trebao izgledati otprilike kao na sljedećoj slici. Slika 1.2: R kao kalkulator Jedan od problema ovakvog načina korištenja R-a jest taj što nam se miješaju naredbe i rezultati, a povijest niza naredbi postaje sve teže vidljiva kako se korištenjem konzole spuštamo sve “niže i niže”. Isto tako, ako iz nekog razloga naredba koju izvršavamo rezultira greškom koju pokušavamo ispraviti, konzola vrlo brzo postaje “prljava” budući da se miješaju korektni pozivi sa izvještajima o greškama čime bilo kakva složenija procedura koju želimo provesti postaje “rastrgana” i nepregledna. Zbog toga analitičari vrlo često koriste tzv. “R skripte” koje omogućuju da vizualno izdvojimo naredbe koje želimo izvršiti od same konzole, ali i dalje uz mogućnost da ih lako upišemo u konzolu, slijedno izvršimo i pogledamo rezultat. 1.3.2 Pisanje R skripti Na alatnoj traci odaberimo File -&gt; New File -&gt; R Script (ili stisnemo kombinaciju tipaka CTRL + SHIFT + N). Vidimo da se “radni dio” na lijevoj strani razdvojio na dva dijela. Gornji dio predstavlja prostor za našu “skriptu” - zapravo niz naredbi koje želimo izvršiti - dok interaktivna konzola sada zauzima donji dio radne plohe. Ukoliko želimo, možemo pomicanjem granice promijeniti veličinu ovih (a i ostalih prozora), no za sada je bitno da imamo pregled i skripte i konzole. Upišimo dvije naredbe u prozor za pisanje skripte - prva neka bude print(&quot;Pozdrav!&quot;) a ispod nje opet jednostavan matematički izraz 3 + 4. Vratimo kursor na prvi redak i stisnimo kombinaciju tipki CTRL + ENTER. Ukoliko smo ispravno pratili navedene korake, naredba na mjestu koje se nalazio kursor automatski će se preslikati u interaktivnu konzolu i izvršiti. Kursor će sada biti na mjestu sljedeće naredbe koju također možemo izvršiti sa CTRL + ENTER. Zaslon bi sada trebao izgledati slično sljedećoj slici. Slika 1.3: R skripta Ovo je zapravo uobičajeni način rada u jeziku R - u prostor za skripte upisujemo naredbe koje potom izvršavamo njihovim automatskim preslikavanjem u konzolu. Ako nešto ne štima s naredbom, lako ju preinačimo i ponovo izvršimo. Ukoliko želimo izvesti blok naredbi, odaberemo ih povlačenjem miša i izvršimo kombinacijom tipaka CTRL + ENTER. Skripte možemo proširiti komentarima (koji počinju znakom # kojeg R interpretira kao “ovaj redak ignoriraj”), a na kraju rada spremiti pod odabranim imenom na čvrsti disk. No možemo otići i korak dalje. Iako su R skripte sasvim adekvatne za ugodan rad u jeziku R, postoji dodatna tehnologija koja nam omogućuje još veću fleksibilnost u radu sa programskim jezikom R - R Markdown. 1.3.3 R Markdown Pisanje R skripti vrlo je slično klasičnom poimanju “programiranja” - pišemo programske naredbe koje se u pravilu izvršavaju slijedno te kojima opcionalno dodajemo komentare u svrhu dokumentacije. No budući da je rad u R-u vrlo često interaktivne prirode te da se kao završni korak neke analize podataka obično očekuje oblikovanje izvještaja koji će na adekvatan način prikazati dobivene rezultate, sučelje RStudio podržava tehnologiju koja omogućuje učinkovitu kombinacije programiranja i strukturiranog dokumentiranja na principu “interaktivne bilježnice”“; analitičar može pisati”čisti&quot; tekst, opcionalno sa formulama, slikama te izmjenama veličine i prirode tekstualnog fonta, da bi potom u takav tekst “ugradio” izvršivi programski kod zajedno sa njegovim rezultatima. Tehnologija koja ovo omogućuje je tzv. R Markdown, koji je relativno nedavno proširen novim konceptom nazvanim R Notebook. Rad ove tehnologije najlakše je prikazati preko primjera - u alatnoj traci odaberimo File -&gt; New File -&gt; R Markdown... te u idućem prozoru odaberimo proizvoljni naslov (npr. Proba), opcionalno ime autora te jednu od opcija za konačni oblik izvještaja (preporučeno HTML zbog najmanje ovisnosti o dodatnim paketima). Za razliku od R skripte, R će kod novog R Markdown dokumenta stvoriti “popunjeni” dokument. Ovo je izvedeno na ovaj način iz jednostavnog razloga da korisnik dobije predložak koji istovremeno služi i kao podsjetnik te kojeg onda lako izmjeni prema svojem nahođenju. Mi ćemo za naše potrebe obrisati veći dio ovog predloška - sve poslije inicijalnog zaglavlja, tj. ispod druge pojave znakova ---. Potom možemo ispod napisati bilo kakav tekst. Znakovima #, ##, ### itd. možemo postaviti naslov određene kategorije (to sada nisu komentari, jer ovo zapravo nije R kod!), dok znakovima * i ** ispred i iza odabranih riječi odabiremo nakošeni ili masni otisak u konačnom izvještaju. Ovo je tzv. čisti “markdown”, tj. običan tekst koji se uz pomoć dodatnih alata može pretvoriti u oblikovani tekst, ukoliko želimo. Kada želimo u ovaj naš “izvještaj” ugraditi programski kod, moramo stvoriti tzv. “isječak” (engl. chunk). To možemo učiniti odabirom Insert -&gt; R na alatnoj traci ili kombinacijom tipaka CTRL + ALT + I. Uočite da isječak počinje i završava posebno odabranim nizom znakova - tri “apostrofa nalijevo” (engl. backticks). Isto tako, početak isječka u vitičastim zagradama opisuje parametre isječka, od čega je najvažniji programski jezik kojeg ćemo koristiti. U ovom udžbeniku ćemo gotovo isključivo koristiti jezik R, iako je moguće koristiti i druge jezike ukoliko su oni instalirani na platformi na kojoj je pokrenut RStudio. Isječak koda ponaša se isto kao i standardna R skripta - možemo upisivati naredbe i izvršavati ih. Razlika je samo u tome što - ukoliko želimo - rezultate možemo vidjeti i odmah u samom R Markdown dokumentu. Ako nam ova opcija smeta možemo ju isključiti (klik na zupčanik u alatnoj traci i odabir Chunk output in console) no u pravilu nam odgovara da se rezultat ugradi u dokument kako bi naknadno mogli ponovo pregledavati rezultate prethodnih isječaka. Ako smo pratili upute, zaslon bi mogao izgledati slično sljedećoj slici: Slika 1.4: R Markdown dokument Ukoliko želimo, možemo pokušati stvoriti “izvještaj” od trenutnog dokumenta. Prvo ga moramo spremiti pod određenim imenom (npr. Proba.rmd), a potom možemo kliknuti na gumb Knit koji će dokument iz čistog teksta pretvoriti u HTML datoteku. R Markdown dokumenti su puno moćniji nego što se možda daje naslutiti do sada prikazanim elementima. Isječcima možemo dodavati niz parametara kako bismo utjecali na njihovo ponašanje. Izlazni oblik može biti PDF, DOCX ali i drugi oblici kao što slajdovi raznih tehnologija, knjige namijenjene mobilnim uređajima, interaktivna Web aplikacija i sl. Udžbenik kojeg čitate zapravo nije ništa drugo do niz RMD datoteka pretvoren u adekvatni oblik kojeg trenutno koristite. Kao što ćemo objasniti u sljedećem poglavlju, RMD datoteke su također i glavni način na kojeg ćete moći na interaktivan način pratiti ovaj udžbenik i isprobavati primjere i zadatke koje slijede. Univerzalnost i fleksibilnost tehnologije R Markdown je iznimno velika, čemu u prilog govori i njezina velika popularnost u R zajednici. 1.4 Kako koristiti ovaj udžbenik? Osnovna ideja ovog udžbenika jest “učenje kroz primjenu”. Zbog toga se u lekcijama u nastavku neće koristiti previše primjera, već se čitatelja potiče da svaki novi koncept usvoji kroz rješavanje niza lakših i težih zadataka. Svako poglavlje koje slijedi ima prateću “radnu bilježnicu”. Jednostavno rečeno, radi se o RMD datoteci koja sadrži sve primjere iz zadatke iz ovog udžbenika, popraćene sažetim tekstom radi lakšeg snalaženja i referenciranja na koncepte koji se obrađuju. Osnovna ideja je da čitatelj paralelno čita udžbenik i rješava radnu bilježnicu, gledajući rješenje zadatka tek nakon što ga samostalno riješi unutar programskog alata. Poneki zadaci zahtijevati će jednostavno uklanjanje znaka # (koji označava “komentar”) sa početka naredbe te njezino izvršavanje. Usprkos trivijalnom pristupu, na ovaj način se ipak jasnije potiče čitatelja za samostalno isprobavanje naredbe, umjesto da samo pogleda njezin rezultat. Drugi zadaci zahtijevati će nešto veći angažman. Konačno, nakon svake lekcije nalazi se niz “Zadataka za vježbu” uz koje se neće nalaziti rješenje te koji će predstavljati svojevrsnu provjeru svih danih koncepata lekcije. Čitateljima se snažno preporučuje rješavanje svih primjera i zadataka prije prelaska na iduću lekciju, budući da lekcije koje slijede pretpostavljaju dobro usvojeno znanje svih do tada obrađenih tema. Naravno, udžbenik je moguće čitati i bez navedenog “interaktivnog” pristupa. Rješenja uz zadatke otkrivaju ispravnu metodu pristupa problemu, a većina naredbi popraćena je ispisom kojeg bi korisnik dobio na zaslonu njihovim izvršavanjem. Usprkos tome, stav autora udžbenika jest da se programski jezici ne mogu učiti čitanjem te da se dodatni trud isprobavanja svih, pa čak i najjednostavnijih koncepata, u konačnici višestruko isplati. Upoznajmo se pobliže sa konceptom radnih bilježnica. Prvo je potrebno pronaći i otvoriti radnu bilježnicu koja odgovara lekciji koju čitate. Nju je lako prepoznati prema odgovarajućem broju lekcije - radna bilježnica za ovu lekciju nosi naziv 01_Uvod_RB.Rmd. Preporučuje se da sve radne bilježnice na kojima namjeravati raditi kopirate negdje na lokalno računalo zajedno sa svim pratećim datotekama koje se nalaze u istoj mapi ako ih ima. Kao što je rečeno, radna bilježnica će u pravilu sadržavati sav programski kod lekcije na koje se odnosi, ali samo dio teksta koliko je dovoljno za lakše snalaženje. Ukoliko ovaj tekst čitate direktno iz radne bilježnice, a ne kao dio udžbenika, možete vidjeti da nedostaje cijeli prethodni dio lekcije; to je zato što se uvodni koraci opisani u njemu tiču koncepata koje je potrebno usvojiti prije korištenja radne bilježnice. Ako ih niste prošli, preporuka je da se vratite i prođete ih te potom nastavite sa primjerima i zadacima koji slijede. Radne bilježnice razlikuju Primjere i Zadatke. Primjere je u pravilu potrebno samo izvršiti. Zadaci s druge strane očekuju izvjesne preinake ili unos novog programskog koda. Kao što je rečeno, udžbenik će postaviti daleko veći naglasak na zadatke. Primjer može izgledati ovako: Primjer - nekoliko jednostavnih naredbi R programskog jezika 3+2 #zbrajanje log(10) # prirodni logaritam! log10(10) # ovo je logaritam baze 10! Usput, komentare pišemo znakom &quot;#&quot; sin(0.5 * pi) # pi je jedna od ugrađenih konstanti ## [1] 5 ## [1] 2.302585 ## [1] 1 ## [1] 1 Naredbe iz primjera možete izvršiti pojedinačno, ili cijeli isječak odjednom kombinacijom tipaka CTRL + SHIFT + ENTER. Nikakve preinake koda nisu nužne (iako često nije loše eksperimentirati sa danim naredbama!). Zadaci s druge strane uvijek traže određenu - makar minimalnu - intervenciju. Zadatak 1.1 - naredbe za provjeru i izmjenu radne mape # izvršite sljedeće naredbe uklanjanjem znaka komentara #getwd() # mapa u kojoj trenutno radimo #setwd(&quot;.&quot;) # ovdje možemo navesti novu radnu mapu ukoliko želimo getwd() # mapa u kojoj trenutno radimo setwd(&quot;.&quot;) # ovdje možemo navesti novu radnu mapu ukoliko želimo Zadatak će se često odnositi na upravo uvedeni koncept. Npr. zgodno je za napomenuti da, iako jezik R podržava operator = za pridruživanje vrijednosti nekoj varijabli, preporučuje se korištenje operatora &lt;- u tu svrhu koji je nešto više “R-ovski”. Također, uočimo da R podržava tzv. autoprint, tj. uvijek će ispisati rezultat zadnje naredbe na zaslon. To znači da ako u isječku stvaramo novu varijablu x te ju želimo ispisati na zaslon, ne moramo kao zadnju naredbu staviti print(x) već je dovoljno staviti samo x. Isprobajmo ovo u zadatku. Zadatak 1.2 - R-ovski operator pridruživanja # upišite `5` u varijablu `x` # potom ispišite varijablu `x` na zaslon x &lt;- 5 x ## [1] 5 Sada kada smo se dobro upoznali sa radnom platformom, možemo početi sa učenjem osnovnih elemenata programskog jezika R. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],
["tipovi.html", "2 Osnovni tipovi podataka i operatori 2.1 Osnovni tipovi podataka 2.2 Operatori 2.3 Nedostajuće, nepoznate i nemoguće vrijednosti Zadaci za vježbu", " 2 Osnovni tipovi podataka i operatori “Osnovni” ili “primitivni” tipovi podataka su temeljni izgradbeni blokovi programskih jezika. Ovdje se najčešće misli na ugrađene mehanizme koji omogućuju pohrane elementarne informacije - najčešće logičkog, numeričkog ili znakovnog tipa. Većina programskih jezika koristi iste ili vrlo slične načine pohrane takvih informacija, što znači da implementira slične osnovne tipove podataka - razlika je često u detaljima kao što su odabrani nazivu tipa, nazivni broj bajtova i sl. U svakom slučaju najčešći prvi korak kod učenja novog programskog jezika jest upoznavanje osnovnih tipova podataka koje isti podržava. Sljedeća stvar koja nas potom može zanimati jest sintaksa jezika, tj. način na kojeg pišemo naredbe koje interpreter jezika može razumjeti i izvršiti. Jezik R u svojoj sintaksi slijedi slične konvencije viđene u jezicima kao što su Python, Ruby ili Java, naravno uz određene specifičnosti (kao i svaki pojedini programski jezik). Neka osnovna sintaksna pravila su: svaka naredba u pravilu mora ići u svoj redak, ali uvlačenje naredbi nije bitno kao ni stavljanje točke-zareza na kraj naredbe; blokove definiramo vitičastim zagradama; tipove varijabli ne moramo definirati unaprijed već se oni samo prilagođavaju pridruženoj vrijednosti; komentari započinju znakom #; i sl. Sintaksu ćemo najbolje naučiti kroz primjere - učenjem elemenata jezika sintaksna pravila često postaju intuitivno jasna. Najbolje je krenuti sa jednostavnim funkcijama i operatorima, što ćemo i učiniti u ovoj lekciji. Lekciju ćemo završiti raspravom o tzv. “nedostajućim” ili “nepostojećim” vrijednostima. Budući da R ima svoj vlastiti način definiranja takve vrste vrijednosti, odmah ćemo pojasniti način na koji su one u R-u implementirane kako bi u lekcijama koje slijede bili pripremljeni za lako upravljanje takvim vrijednostima (koje se vrlo često susreću u radu sa stvarnim podatkovnim skupovima). 2.1 Osnovni tipovi podataka R poznaje šest osnovnih tipova podataka: tip izvorni naziv tipa primjeri logički logical TRUE, FALSE ili T, F cjelobrojni integer 2L, 5L, 123456789L realni double 4, 6, 3.14, 2e5 kompleksni complex 5 + 2i, 7 + 1i znakovni character &quot;A&quot;, &quot;B&quot;, &quot;Pero&quot;, &quot;ABCDEFGHijklmnoPQRSTUVwyz&quot; bajtovi raw as.raw(2), charToRaw(&quot;1&quot;) Neke opaske: cjelobrojni i realni tipovi se često zajedno tretiraju kao tip numeric (iako ovo nije u potpunosti konzistentno!) kompleksni tip mora imati deklariranu imaginarnu konstantu čak i ako je ona 1 (2 + i nije dobar zapis!) tip “sirovih” bajtova se relativno rijetko koristi Provjeru da li je neka varijabla određenog tipa možemo raditi uz pomoć funkcije is.&lt;naziv_tipa&gt;. Ovo ćemo isprobati u sljedećem zadatku. Prije nego što počnemo s rješavanjem uvedimo jedan novitet: u zadacima gdje ispisujemo više stvari na zaslon korisno je vizualno odvojiti različite segmente ispisa kako bismo lakše shvatili na koji dio koda se referenciraju. U tu svrhu ćemo koristiti naredbu cat(&quot;-----------\\n&quot;) koja jednostavno na zaslon ispisuje niz crtica i prelazi u novi red. Mogli smo koristiti i funkciju print(), no ona uvijek započinje ispis sa indeksom elementa dok naredba cat predstavlja “sirovi” ispis, što nam u ovom slučaju više odgovara. Zadatak 2.1 - provjera tipova podataka #isprobajte sljedeće naredbe: #is.logical(FALSE) #is.integer(2L) #is.double(1.11) # izvedite sljedeće provjere: # da li je 5L numerički tip? # da li je 3.14 numerički tip? # da li je &quot;ABC&quot; znakovni tip? # da li je 4 + 2i kompleksni tip? # da li je 5 cjelobrojni tip? is.logical(FALSE) is.integer(2L) is.double(1.11) cat(&quot;-----------\\n&quot;) is.numeric(5L) is.numeric(3.14) is.character(&quot;ABC&quot;) is.complex(4 + 2i) is.integer(5) ## [1] TRUE ## [1] TRUE ## [1] TRUE ## ----------- ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] FALSE Da li ste uočili nešto neobično u ovim provjerama? Pokušajte objasniti dobiveni rezultat. Tip neke varijable ili konstante možemo dohvatiti uz pomoć funkcija typeof ili class. Razlika između njih je sljedeća: typeof - dohvaća “primitivni” ili “osnovni” tip podatka (integer, double ) class - “objektni tip”, zapravo vrijednost atributa class Zadatak 2.2 - dohvat naziva tipa podatka # ispišite tipove sljedećih konstanti: TRUE, 2L, F, 3.14, &quot;ABC&quot; # ispišite klase istih konstanti. Ima li razlike? typeof(TRUE) typeof(2L) typeof(F) typeof(3.14) typeof(&quot;ABC&quot;) cat(&quot;-----------\\n&quot;) class(TRUE) class(2L) class(F) class(3.14) class(&quot;ABC&quot;) ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;double&quot; ## [1] &quot;character&quot; ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;character&quot; Podatke možemo eksplicitno pretvarati iz jednog tipa u drugi uz pomoć funkcije as.&lt;naziv_tipa&gt;: Zadatak 2.3 - pretvorba tipova podataka # Izvedite sljedeće pretvorbe i ispišite rezultat # 2.35 u integer # TRUE u numeric # 100L u character # 2.35 u character # 2e2 u character # 0 u logical # 2.75 u logical as.integer(2.35) as.numeric(TRUE) as.character(100L) as.character(2.35) as.character(2e2) as.logical(0) as.logical(2.75) ## [1] 2 ## [1] 1 ## [1] &quot;100&quot; ## [1] &quot;2.35&quot; ## [1] &quot;200&quot; ## [1] FALSE ## [1] TRUE R će sam provoditi implicitnu pretvorbu ukoliko je moguća: Zadatak 2.4 - implicitna pretvorba # napišite izraze koji odgovaraju sljedećem i ispišite rezultat: # aritmetički operator između logičke i numeričke varijable # aritmetički operator između cjelobrojne i numeričke varijable # logički operator negacije primjenjen na numeričku varijablu # aritmetički operator između logičke i numeričke varijable TRUE + 5 # aritmetički operator između cjelobrojne i numeričke varijable 5L + 3.14 # logički operator negacije primjenjen na numeričku varijablu !25 ## [1] 6 ## [1] 8.14 ## [1] FALSE Implicitna pretvorba će se izvesti samo ako je smislen - npr. aritmetički operator između znakovne i numeričke varijable rezultirati će greškom. 2.2 Operatori Kao i u drugim programskim jezicima, R dozvoljava korištenje operatora u izrazima. Neki od češće korištenih operatora su: aritmetički +, -, *, /, ** (potencija), %% (modulo), %/% (cjelobrojno dijeljenje) usporedni &lt;, &lt;=, &gt;, &gt;=, ==, != logički ! (negacija), &amp;&amp; (skalarni “i”), || (skalarni “ili”), &amp; (vektorski “i”), | (vektorski “ili”) pridruživanje &lt;- ili = Zadatak 2.5 - operatori # isprobajte izraze `5 / 2` i `5 %/% 2` # provjerite koliko iznosi &quot;17 na kvadrat&quot; i &quot;ostatak dijeljenja 101 sa 12&quot; # provjerite što je rezultat sljedećih izraza: `17 &gt; 13`, `!TRUE`, `5 &amp;&amp; 0`, `0. || 2` # isprobajte izraze `5 / 2` i `5 %/% 2` 5 / 2 5 %/% 2 cat(&quot;-----------\\n&quot;) # provjerite koliko iznosi &quot;17 na kvadrat&quot; i &quot;ostatak dijeljenja 101 sa 12&quot; 17 ^ 2 101 %% 12 cat(&quot;-----------\\n&quot;) # provjerite što je rezultat sljedećih izraza: `17 &gt; 13`, `!TRUE`, `5 &amp;&amp; 0`, `0. || 2`, 17 &gt; 13 !TRUE 5 &amp;&amp; 0 0. || 2 ## [1] 2.5 ## [1] 2 ## ----------- ## [1] 289 ## [1] 5 ## ----------- ## [1] TRUE ## [1] FALSE ## [1] FALSE ## [1] TRUE Logičke vrijednosti i usporedne operatore najčešće ćemo koristiti kod tzv. “uvjetnog izvođenja naredbi”, poznatog iz drugih programskih jezika kao “IF ELSE” naredba. U R-u njezina sintaksa izgleda ovako: if (izraz) {blok} else {blok} Isprobajmo ovu naredbu na sljedećem zadatku: Zadatak 2.6 - uvjetno izvođenje naredbi # napišite naredbu koja izvodi sljedeće: # &quot;ako je 100 paran broj ispiši &#39;Uspjeh!&#39;&quot; if (100 %% 2 == 0) print(&quot;Uspjeh!&quot;) ## [1] &quot;Uspjeh!&quot; Uočili smo gore da imamo dvije vrste logičkih operatora za “i” i “ili”. Razliku ćemo objasniti kasnije, za sada je dovoljno reći da se kod uvjetnog izvođenja naredbi ili programskih petlji gotovo isključivo koristimo operatorima &amp;&amp; i || (“C++ - ovski” operatori!). Isto tako, već smo spomenuli da R nudi dva operatora pridruživanja, &lt;- i =. Pogledajmo ima li očitih razlika između njih. Zadatak 2.7 - operatori pridruživanja # stvorite varijable x i y i objema dodijelite broj 5, jednoj sa operatorom &lt;-, # drugoj sa operatorom = # ispišite varijable na zaslon # uočavate li razliku između ova dva operatora? x &lt;- 5 y = 5 x y ## [1] 5 ## [1] 5 Kao što smo se mogli posvjedočiti, nema uočljivih razlika između operatora &lt;- i =. Neke sitnije razlike zapravo postoje, no one nemaju gotovo utjecaj na uobičajeno korištenje ovog operatora u praksi. U literaturi se za pridruživanje vrijednosti novim varijablama može vidjeti i jedna i druga inačica, no mi ćemo u nastavku primarno i konzistentno koristiti &lt;-, ponajviše zato kako bi programski kod bio vizualno distinktivniji od drugih programskih jezika. Kod pridruživanja pazimo da je s lijeve strane tzv. “lijeva vrijednost” (engl. lvalue). Ovo u programerskom smislu interpretiramo kao “nešto u što se može pohraniti izračunata vrijednost”. x + 1 &lt;- 2 # greška!!!] U pravilu se u R-u kao lvalue koristi varijabla, iako se tu ponekad može pojaviti i poziv funkcije. Ovu možda inicijalno zbunjujuću pojavu razjasniti ćemo kasnije. Imenovanje varijabli uglavnom slijedi pravila iz drugih programskih jezika - dozvoljena su slova, brojke, podcrta ali i točka . Prvi simbol mora biti slovo ili točka. .mojaVarijabla &lt;- 5 #OK moja.Varijabla &lt;- 5 #OK _mojaVarijabla &lt;- 5 # nije OK 123Varijabla &lt;- 5 # nije OK U praksi za varijable složenih imena trebamo odabrati jednu od sljedećih konvencija: mojaVarijabla &lt;- 1 # tzv. camelcase moja_varijabla &lt;- 2 # podcrta ili moja.varijabla &lt;- 3 # točka Bitno je da u programskom kodu ne miješamo konvencije tj. da nakon odabira budemo konzistentni. Ukoliko baš inzistiramo na čudnim imenima koja koriste specijalne znakove, onda ih moramo staviti pod tzv. “lijeve jednostruke apostrofe” (engl. backticks): Zadatak 2.8 - ime varijable sa specijalnim znakovima # upišite proizvoljno ime sa specijalnim znakovima unutar lijevih apostrofa # i ispišite vrijednost varijable #`` &lt;- 2 `!%^$*@__=` &lt;- 2 `!%^$*@__=` ## [1] 2 Ovakav način imenovanja varijabli nije previše koristan u praksi, ali ima i svoju svrhu - budući da su operatori u R-u zapravo funkcije (čija su imena doslovno +, ** i sl.) upotrebom lijevih apostrofa možemo ih direktno referencirati u njihovom originalnom obliku, što se može pokazati vrlo praktičnim kod tzv. funkcijskog programiranja (o čemu ćemo govoriti u jednoj od budućih lekcija). Pridjeljivanje vrijednosti novim nazivima varijabli mi zapravo stvaramo nove varijable u radnoj okolini (koja se u R-u naziva “globalna okolina”). Sve varijable koje smo do sada stvorili možemo vidjeti uz pomoć funkcije ls(). Ukoliko želimo obrisati neke varijable, samo navedemo njihova imena u pozivu funkcije rm() (npr. rm(x, y, z)). Za brisanje svih varijabli iz radne okoline koristimo poziv rm(list=ls()), s time što tu moramo biti oprezni (nema “undo”!). Zadatak 2.9 - ispis i brisanje varijabli globalne okoline # ispišite sve do sada stvorene varijable globalne okoline # obrišite neke od gore ispisanih varijabli - npr. rm(x, y, z) # ponovo ispišite dostupne varijable # obrišite SVE varijable globalne okoline # (oprezno s ovim pozivom u praksi!) # uvjerite se da je globalna okolina prazna # ispišite sve do sada stvorene varijable globalne okoline ls() # obrišite neke od upravo ispisanih varijabli - npr. rm(x, y, z) # ponovo ispišite dostupne varijable rm(x, y) ls() # obrišite SVE varijable globalne okoline # (oprezno s ovim pozivom u praksi!) # uvjerite se da je globalna okolina prazna rm(list=ls()) ls() Konačno, kad god nam treba pomoć oko neke funkcije, imamo sljedeće opcije na raspolaganju: napišemo samo &lt;ime_funkcije&gt; (bez zagrada sa parametrima) i stisnemo - ukoliko je funkcija pisana u R-u (a nije samo proxy prema implementaciji u C-u) na zaslon ćemo dobiti ispis izvornog koda funkcije napišemo help(&lt;ime_funkcije&gt;) ili ?&lt;ime_funkcije&gt; čime dobijamo stranicu pomoći o funkciji sa popisom parametara, primjerima i sl. napišemo example(&lt;ime_funkcije&gt;) pri čemu dobijemo popis primjera korištenja funkcije i dobivenih rezultata Sljedeći isječak koda prikazuje način korištenja gornjih metoda (zbog štednje prostora ne prikazujemo njihov rezultat). #programski kod funkcije `ls` ls # pomoć za funkciju `ls` ?ls # ili help(ls) # primjeri korištenja funkcije `ls` example(ls) 2.3 Nedostajuće, nepoznate i nemoguće vrijednosti U R-u postoji tri načina modeliranja “nepostojećih” vrijednosti: NA - (not available) nedostajuća ili nepoznata vrijednost određenog tipa NaN - (not a number) “nemogući” broj, npr. 0/0 NULL - nepostojeća vrijednost, doslovno “ništa” Zadatak 2.10 - rad sa NA, NaN i NULL # Koliko je &quot;5 + nepoznati broj&quot;? # Koliko je &quot;5 + nepostojeći broj&quot;? # provjerite klase sljedećih konstanti i izraza: # NA # aritmetička operacija između numeric i NA # NaN # NULL # Koliko je &quot;5 + nepoznati broj&quot;? 5 + NaN # Koliko je &quot;5 + nepostojeći broj&quot;? 5 + NA cat(&quot;-----------\\n&quot;) # provjerite klase sljedećih konstanti i izraza i objasnite rezultat: # NA # aritmetička operacija između numeric i NA # NaN # NULL class(NA) # logički tip je &quot;najslabiji&quot;! class(5 + NA) class(NaN) class(NULL) ## [1] NaN ## [1] NA ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;numeric&quot; ## [1] &quot;NULL&quot; Provjeru nedostajućih vrijednosti radimo slično provjeri tipova podataka - koristimo funkcije is.na, is.nan i is.null. Moramo voditi računa da je NaN zapravo podvrsta od NA te da je NULL zapravo potpuno zasebna klasa sa specifičnim ponašanjem - pokušaj aritmetičkih ili logičkih operacija nad NULL vrijednosti neće rezultirati “novom” nepostojećom vrijednosti već upozorenjima i “praznim” rezultatima. Ovo je posebno bitno napomenuti poznavateljima jezika SQL - ono što je NULL u SQL-u je NA u R-u i to je ono što u pravilu koristimo u praksi, dok NULL ima vrlo specifične primjene te ga puno rjeđe koristimo u programskom kodu. Zadatak 2.11 - provjera vrijednosti NA, NaN i NULL # Što je od idućeg NA? NA, NaN, NULL, &quot;&quot;, 0 # Što je od idućeg NaN? NA, NaN, NULL # Što je od idućeg NULL? NA, NaN, NULL # Što je od idućeg NA? NA, NaN, NULL, &quot;&quot;, 0 is.na(NA) is.na(NaN) is.na(NULL) is.na(&quot;&quot;) is.na(0) cat(&quot;-----------\\n&quot;) # Što je od idućeg NaN? NA, NaN, NULL is.nan(NA) is.nan(NaN) is.nan(NULL) cat(&quot;-----------\\n&quot;) # Što je od idućeg NULL? NA, NaN, NULL is.null(NA) is.null(NaN) is.null(NULL) ## [1] TRUE ## [1] TRUE ## logical(0) ## [1] FALSE ## [1] FALSE ## ----------- ## [1] FALSE ## [1] TRUE ## logical(0) ## ----------- ## [1] FALSE ## [1] FALSE ## [1] TRUE Za kraj posvetimo se malo NA vrijednosti, budući da ćemo ju vrlo često susretati u praksi. Pojednostavljeno rečeno, ukoliko se pojavljuju NA vrijednosti, možemo očekivati sljedeće nuspojave: rezultati aritmetičkih izraza rezultiraju sa NA vrijednosti rezultati poziva nekih funkcija rezultiraju sa NA (osim ako ne navedemo kompenzacijske akcije, kao npr. parametar na.rm = T koji zapravo znači “ignoriraj NA”) rezultati logičkih izraza mogu ali ne moraju rezultirati sa NA vrijednosti ovisno o tom da li izraz ovisi o NA ili ne (npr. TRUE || NA ima rezultat TRUE, ali FALSE || NA ima rezultat NA) S ovim zadnjim moramo biti posebno oprezni, budući da NA u uvjetnom izrazu rezultira greškom: if (NA &lt; 2) print(&quot;Uspjeh!&quot;) # greška!! U ovoj lekciji upoznali smo se sa osnovnim elementima jezika R. U radu s R-om u pravilu radimo sa složenim tipovima podataka koje ćemo upoznati u nastavku - a to su vektori, matrice, podatkovni okviri i liste. Zadaci za vježbu Što je rezultat sljedećih naredbi? Razmislite o mogućem rezultatu prije izvršavanja. as.complex(2) as.integer(-3.25) as.logical(&quot;0&quot;) as.numeric(TRUE) as.character(11.5+2i) as.numeric(&quot;ABC&quot;) Kako u R-u izgledaju sljedeći opisni izrazi: “tri puta deset na devetu” “logaritam od 5” “cjelobrojno dijeljenje 10 sa 3” “ostatak cjelobrojnog dijeljenja 10 sa 3” “tangens od 75 stupnjeva” | Uz pomoć if izraza provjerite da li se rezultat dijeljenja nule s nulom smatra kao vrijednost NA, NaN ili NULL. Ubacite u varijablu x vrijednost 5. Ispišite sve varijable okoline. Potom u varijablu x ubacite NULL. Postoji li i dalje ova varijabla? Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],
["vektori.html", "3 Vektori, matrice i liste 3.1 Vektori 3.2 Indeksni vektori 3.3 Matrice i polja 3.4 Liste Zadaci za vježbu", " 3 Vektori, matrice i liste 3.1 Vektori Vektor je jedan od “složenih” tipova podataka u jeziku R, u smislu da sadržava više vrijednosti istog tipa. On je kao takav sličan pojmu “polja” u jeziku C. No ovdje postoji jedna bitna razlika, koju je nužno usvojiti budući da se radi o jednoj od najvažnijih karakteristika jezika R - u R-u je (gotovo) svaki tip varijable zapravo vektor. Čak i varijable i konstante koje smo koristili u prethodnoj lekciji su zapravo bili jednoelementni vektori. Ovo ima dalekosežne posljedice o kojima ćemo detaljno raspravljati u nastavku, a za početak se prvo upoznajmo sa sintaksom stvaranja i upravljanja vektorima. 3.1.1 Stvaranje vektora Novi vektor (koji ima više od jednog elementa) stvaramo uz pomoć funkcije c (od engl. combine). # numerički vektor m &lt;- c(1, 2, 3, 4, 5) # logički vektor v &lt;- c(T, F, T) # znakovni vektor imena &lt;- c(&quot;Ivo&quot;, &quot;Pero&quot;, &quot;Ana&quot;) Dakle, jednostavno rečeno, vektor je uređeni skup elemenata istog tipa. Ovo konkretno znači da svi elementi vektora moraju biti istog tipa. Ako stvaramo novi vektor sa elementima različitih tipova podataka, R će sve elemente automatski pretvoriti u “najjači” tip, što će na kraju postati i tip samog vektora (termin “jači” tip u ovom kontekstu označavaju mogućnost tipa da pohrani svu informaciju “pohranjenu u slabiji”slabijeg&quot;&quot; tipa, a u općenitom slučaju pretvorba ide u smjeru logički -&gt; numerički -&gt; znakovni tip). Zadatak 3.1 - stvaranje vektora # stvorite novi vektor `x` sa četiri proizvoljna elementa sljedećih tipova: # logički, realni, znakovni i cjelobrojni # ispišite na zaslon sadržaj vektora i njegovu klasu # stvorite novi vektor `x` sa četiri proizvoljna elementa sljedećih tipova: # logički, realni, znakovni i cjelobrojni x &lt;- c(T, 1.25, &quot;Ivo&quot;, 10L) # ispišite na zaslon sadržaj vektora i njegovu klasu x class(x) ## [1] &quot;TRUE&quot; &quot;1.25&quot; &quot;Ivo&quot; &quot;10&quot; ## [1] &quot;character&quot; Vektor možemo eksplicitno pretvoriti u drugi tip uz pomoć već upoznatih funkcija as.&lt;naziv_tipa&gt;. Ukoliko je pretvorbu nemoguće provesti element će biti pretvoren u NA uz prikladno upozorenje. Zadatak 3.2 - eksplicitna pretvorba tipa vektora x &lt;- c(1, T, 2L) y &lt;- c(1L, 2L, 3L) z &lt;- c(1.25, TRUE, &quot;Ana&quot; ) # razmislite o mogućem rezultatu a potom pokušajte izvršiti sljedeće pretvorbe # vektor `x` u numerički tip # vektor `y` u znakovni tip # vektor `z` u cjelobrojni tip # razmislite o mogućem rezultatu a potom pokušajte izvršiti sljedeće pretvorbe # vektor `x` u numerički tip # vektor `y` u znakovni tip # vektor `z` u cjelobrojni tip as.numeric(x) as.character(y) as.integer(z) ## Warning: NAs introduced by coercion ## [1] 1 1 2 ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; ## [1] 1 NA NA Možete li odgovoriti na pitanje - zašto u zadnjem primjeru vrijednost TRUE nije postala 1L već NA? Pokušajte ispisati vektor z i uočite rezultate implicitne pretvorbe koju ste možda zanemarili (a koja je logičku vrijednost TRUE pretvorila u niz znakova &quot;TRUE&quot; kojeg više nije moguće “vratiti” u numeričku vrijednost 1L). Funkcijom c možemo također i više vektora spojiti u jedan: a &lt;- c(1, 2, 3) b &lt;- c(4, 5) c &lt;- c(6, 7, 8) # varijablu smijemo nazvati &quot;c&quot; usprkos tome što postoji funkcija c() d &lt;- c(a, b, c) # d je sada c(1, 2, 3, 4, 5, 6, 7, 8) Pored funkcije c, R nudi i dodatne pogodne načine stvaranja novih vektora: : - operator “raspona” (engl. range), pri čemu dajemo raspon od gornje do donje granice, obje uključive seq - funkcija sekvence (engl. sequence), radi slično operatoru raspona, ali s dodatnim mogućnostima rep - funkcija repliciranja (engl. replicate), ponavlja zadane elemente zadani broj puta Zadatak 3.3 - pomoćne funkcije za stvaranje vektora # ispišite rezultate sljedećih naredbi # 1:5 # rep(c(1, 2, 3), times = 3) # rep(c(1, 2, 3), each = 3) # seq(1, 5, by = 0.5) # ispišite rezultate sljedećih naredbi 1:5 rep(c(1, 2, 3), times = 3) rep(c(1, 2, 3), each = 3) seq(1, 5, by = 0.5) ## [1] 1 2 3 4 5 ## [1] 1 2 3 1 2 3 1 2 3 ## [1] 1 1 1 2 2 2 3 3 3 ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 Vektore možemo stvoriti i uz pomoć funkcija koje odgovaraju imenima tipova vektora (numeric, character i sl.) pri čemu kao parametar navodimo željenu duljinu vektora. Ovo često radimo kao “pripremu” vektora za naknadno punjenje stvarnim vrijednostima, tj. svojevrsnu rezervaciju mjesta u radnoj memoriji. Ono što je interesantno jest činjenica da možemo stvoriti i “prazan” vektor određenog tipa koji je i dalje vektor, samo sa duljinom nula (a kojem npr. uz pomoć funkcije c možemo naknadno dodavati elemente). x &lt;- numeric(2) # vektor se puni &quot;nultim&quot; elementima, u ovom slučaju (0, 0) y &lt;- character(5) z &lt;- integer(0) # &quot;prazan&quot; vektor! z &lt;- c(z, 1) # dodaj vektoru element 1 (zapravo &quot;spoji prazan vektor i element 1&quot;) Konačno, provjeru da li neki vektor sadrži određeni element možemo napraviti uz pomoć operatora %in%: 4 %in% seq(1, 10, 2) # vraća FALSE &quot;d&quot; %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) # vraća TRUE Pogledajmo sada kako pristupiti pojedinim elementima vektora 3.1.2 Operator [ Elementima vektora pristupamo preko indeksnog operatora [, uz pomoć kojeg možemo i mijenjati elemente vektora: a &lt;- c(2, 4, 6) a[1] # ispisuje vrijednost 2 a[2] &lt;- 5 # element na 2. mjestu postaje 5 a[5] &lt;- 7 # na 5. mjesto dodaje se 7, a &quot;rupa&quot; se popunjava sa NA a ## [1] 2 ## [1] 2 5 6 NA 7 Uočite jednu pomalo neuobičajenu činjenicu - prvi element vektora u R-u ima indeks 1, a ne 0! Ovo je bitna razlika u odnosu na referenciranje elemenata u drugim programskim jezicima. Razlog ove specifičnosti je jednostavan - R se primarno smatra jezikom za analizu podataka, poglavito u tabličnom obliku, a u praksi je puno lakše brojati retke ili stupce redoslijedom kako se pojavljuju u podatkovnom skupu nego raditi “posmak za 1”. Primjer gore zapravo prikazuje vrlo pojednostavljeni slučaj pristupanja elementima vektora i način njihove izmjene. Naime, jedna od specifičnosti jezika R je tzv. vektoriziranost, tj. princip da se u R-u vrlo često radi “više stvari odjednom” - ne toliko u smislu paralelnog izvršavanja, već u smislu zadavanja naredbi što želimo da se izvede. Konkretno, u slučaju referenciranja elemenata vektora vrlo rijetko dohvaćamo ili mijenjamo elemente jedan po jedan, već obuhvaćamo veći broj elemenata odjednom korištenjem principa vektorizacije i recikliranja. Razumijevanje ovih pojmova presudno je za svladavanje jezika R, tako da ćemo ih detaljno objasniti u nastavku. 3.1.3 Principi vektorizacije i recikliranja Pojam vektorizacije ili bolje rečeno vektoriziranih operacija i funkcija jednostavno znači da se operacije rade nad više elemenata odjednom. Ako zadamo R-u da radi neku operaciju ili funkciju nad nekim vektorom vrijednosti, R će funkciju ili operaciju izvesti nad svakim elementom posebno i vratiti rezultantni vektor kao rezultat. Isto tako, ako provodimo binarnu operaciju nad dva vektora, ona će se provesti nad “uparenim” ili “poravnatim” elementima obaju vektora (pretpostavimo za sada da su vektori jednake duljine). Zadatak 3.4 - princip vektorizacije x &lt;- seq(-5, 5, 1) a &lt;- 1:3 b &lt;- 4:6 # pozovite funkciju `abs` za računanje apsolutne vrijednosti # nad vektorom `x` i ispišite rezultat # zbrojite vektore `a` i `b` uz pomoć operatora `+` # i ispišite rezultat # pomnožite vektore `a` i `b` uz pomoć operatora `*` # i ispišite rezultat # pozovite funkciju `abs` za računanje apsolutne vrijednosti # nad vektorom `x` i ispišite rezultat abs(x) cat(&quot;-----------\\n&quot;) # zbrojite vektore `a` i `b` uz pomoć operatora `+` # i ispišite rezultat a + b cat(&quot;-----------\\n&quot;) # pomnožite vektore `a` i `b` uz pomoć operatora `*` # i ispišite rezultat a * b ## [1] 5 4 3 2 1 0 1 2 3 4 5 ## ----------- ## [1] 5 7 9 ## ----------- ## [1] 4 10 18 Pažljivo razmotrite rezultate prethodnog zadatka. Ukoliko je potrebno, skicirajte vektore a i b na papiru sa vertikalno poslaganim elementima i uočite kako radi paralelno “uparivanje” elemenata. Primijetite da ovdje ne pričamo o “vektorskim operacijama” u strogom matematičkom smislu, već o poravnavanju elemenata dvaju nizova i provođenja jednostavnih operacija nad svakim od tih parova. Ovo je pogotovo očito u zadnjem primjeru gdje nema nikakvog “množenja vektora” u nekoj od matematičkih interpretacija, već se provodi jednostavno množenje paralelnih elemenata dvaju vektora. Što ako vektori nisu jednake duljine? R u ovom slučaju koristi princip recikliranja. Princip recikliranja navodi da se kod nejednake duljine vektora kraći vektor “reciklira” onoliko puta koliko je potrebno da se dostigne duljina duljeg vektora. Najčešći scenarij korištenja ovog principa su operacije u kojima je s jedne strane vektor s više elemenata a s druge strane jednoelementni vektor koji se onda reciklira za svaki element “velikog” vektora. Ono što bismo trebali izbjegavati jest scenarij recikliranja gdje duljina “velikog” vektora nije višekratnik duljine “malog” - R će i dalje reciklirati kraći vektor, samo će ga na kraju morati “odrezati” što će rezultirati odgovarajućim upozorenjem. Zadatak 3.5 - princip recikliranja a &lt;- 1:4 b &lt;- c(1, 2) c &lt;- rep(5, 3) # udvostručite elemente vektora `a` i ispišite rezultat # podijelite vektor `a` vektorom `b` i ispišite rezultat # pomnožite vektore `a` i `c` i ispišite rezultat a &lt;- 1:4 b &lt;- c(1, 2) c &lt;- rep(5, 3) # udvostručite elemente vektora `a` i ispišite rezultat 2 * a # podijelite vektor `a` vektorom `b` i ispišite rezultat a / b # pomnožite vektore `a` i `c` i ispišite rezultat a * c ## Warning in a * c: longer object length is not a multiple of shorter object ## length ## [1] 2 4 6 8 ## [1] 1 1 3 2 ## [1] 5 10 15 20 Sada konačno možemo demistificirati razliku između “skalarnih” i “vektorskih” logičkih operatora (podsjetimo se, skalarni su || i &amp;&amp;, dok su vektorski | i &amp;). Skalarni logički operatori namijenjeni su korištenju sa jednoelementnim vektorima, vraćaju jedinstvenu vrijednosti TRUE ili FALSE te su pogodni za korištenje raznim u uvjetnim izrazima. Vektorski logički operatori koriste standardne R-ove principe vektorizacije i recikliranja, tj. namijenjeni su radu sa logičkim vektorima i kao rezultat daju logički vektor Zadatak 3.6 - skalarni i vektorski logički operatori a &lt;- c(T, F, F) b &lt;- c(T, T, F) # primjenite skalarnu i vektorsku inačicu logičkog operatora &quot;ili&quot; # nad vektorima `a` i `b` i ispišite rezultat # primjenite skalarnu i vektorsku inačicu logičkog operatora &quot;ili&quot; # nad vektorima `a` i `b` i ispišite rezultat a || b a | b ## [1] TRUE ## [1] TRUE TRUE FALSE Vidimo da će skalarna inačica “iskoristiti” samo prvi par elemenata logičkih vektora. Ovo znači da ju u teoriji možemo koristiti u uvjetnim izrazima, iako za to nema opravdanog smisla, a R će se u tom slučaju oglasiti upozorenjem kako bi nam obratio pažnju na činjenicu da vjerojatno koristimo “krivi” operator. Sljedeći primjer sa usporednim operatorima će možda inicijalno izgledati trivijalan, no potrebno je obratiti posebnu pažnju na rezultate koje ćemo dobiti budući da će oni imati vrlo važnu primjenu u nastavku lekcije. Dakle, pogledajmo što se događa kod vektorizacije usporednih operatora. Zadatak 3.7 - vektorizacija usporednih operatora x &lt;- 1:5 y &lt;- seq(-10, 10, 5) #ispišite x i y #ispišite rezultat naredbe x &gt; y i objasnite rezultat #ispišite rezultat naredbe x &lt; 3 i objasnite rezultat #ispišite x i y x y cat(&quot;-----------\\n&quot;) #ispišite rezultat naredbe x &gt; y i objasnite rezultat x &gt; y cat(&quot;-----------\\n&quot;) #ispišite rezultat naredbe x &lt; 3 i objasnite rezultat x &lt; 3 ## [1] 1 2 3 4 5 ## [1] -10 -5 0 5 10 ## ----------- ## [1] TRUE TRUE TRUE FALSE FALSE ## ----------- ## [1] TRUE TRUE FALSE FALSE FALSE Dakle vektoriziranom primjenom usporednih operatora nad vektorima (ili kombinacijama vektora i “skalara”) kao rezultat dobivamo logičke vektore. Interpretacija ovih rezultata je ključna - ona zapravo odgovara na pitanje “na kojim indeksima je zadovoljen uvjet zadan ovim izrazom”? Drugim riječima, dobiveni rezultati zapravo predstavljaju predložak koji opisuje kako filtrirati elemente prema zadanom principu. Ovo je osnovni temelj tzv. logičkog referenciranja, što je jedna od metoda dohvaćanja elemenata vektora koje ćemo upoznati u nastavku. 3.2 Indeksni vektori Već smo naučili da elementu polja možemo pristupiti preko numeričkog indeksa (a nismo zaboravili ni činjenicu da prvi element ima indeks 1). Ovaj koncept možemo proširiti tako da iz vektora uzimamo više elemenata odjednom. što se često naziva “rezanjem” vektora (engl. slicing). Osnovni princip odabira više elemenata odjednom je jednostavan - samo moramo na određeni način navesti indekse elemenata koje želimo. R nudi tri osnovna načina referenciranja: lokacijsko referenciranje (engl. integer- or location-based referencing) uvjetno referenciranje (engl. conditional- or boolean-based referencing) imensko referenciranje (engl. label-based referencing) Koje referenciranje ćemo odabrati ovisi o tome želimo li elementima pristupati ovisno o njihovoj lokaciji, imenu ili prema zadanom uvjetu, a svaki tip referenciranja u suštini se svodi na korištenje vektora određenog tipa kao parametra za operator referenciranja. Ovakav vektor se zbog svoje uloge naziva “indeksnim vektorom”. Upoznajmo detaljno svaki od tipova referenciranja. 3.2.1 Lokacijsko referenciranje Lokacijsko referenciranje je poopćenje već upoznatog principa referenciranja gdje navodimo redni broj elementa koji nas zanima. Ako želimo više elemenata, jednostavno navedemo njihove indekse “zapakirane” u numerički vektor. Pokušajte riješiti sljedeći zadatak korištenjem odgovarajućih numeričkih vektora kao parametara indeksnog operatora. Zadatak 3.8 - lokacijsko referenciranje x &lt;- 1:10 # ispišite prvi element vektora x # ispišite prva tri elementa vektora x # ispišite prvi, peti i sedmi element vektora x # ispišite prvi element vektora x x[1] # ispišite prva tri elementa vektora x x[1:3] # ispišite prvi, peti i sedmi element vektora x x[c(1,5,7)] ## [1] 1 ## [1] 1 2 3 ## [1] 1 5 7 Dakle, lokacijski indeksni vektor nije ništa drugo nego običan numerički vektor kojeg koristimo zajedno sa indeksnim operatorom da bi odredili koje elemente nekog drugog vektora želimo “zadržati”. Pogledajmo još neke značajke lokacijskih indeksnih vektora: Zadatak 3.9 - lokacijsko referenciranje (2) x &lt;- 1:10 # odgovorite na sljedeća pitanja uz pomoć prikladnog primjera # što vraća indeks 0? # što vraća negativni indeks? # što vraća indeks izvan granica duljine vektora x &lt;- 1:10 # odgovorite na sljedeća pitanja uz pomoć prikladnog primjera # što vraća indeks 0? x[0] # što vraća negativni indeks? x[-1] # što vraća indeks izvan granica duljine vektora x[20] ## integer(0) ## [1] 2 3 4 5 6 7 8 9 10 ## [1] NA Indeksni operator se ne koristi samo za dohvaćanje elemenata. Kombinacijom indeksnog operatora i operatora pridruživanja možemo mijenjati elemente vektora (i to također po principu “više elemenata odjednom”: Zadatak 3.10 - lokacijsko referenciranje i pridruživanje a &lt;- 1:10 # postavite sve elemente vektora `a` od drugog do osmog mjesta na nulu # ispišite vektor `a` b &lt;- 1:20 b[2 * 1:5] &lt;- 0 # razmislite kako izgleda vektor `b` nakon gornje naredbe # ispišite vektor `b` i objasnite rezultat a &lt;- 1:10 # postavite sve elemente vektora `a` od drugog do osmog mjesta na nulu # ispišite vektor `a` a[2:8] &lt;- 0 a b &lt;- 1:20 b[2 * 1:5] &lt;- NA # razmislite kako izgleda vektor `b` nakon gornje naredbe # ispišite vektor `b` i objasnite rezultat b ## [1] 1 0 0 0 0 0 0 0 9 10 ## [1] 1 NA 3 NA 5 NA 7 NA 9 NA 11 12 13 14 15 16 17 18 19 20 3.2.2 Uvjetno referenciranje Ako smo pažljivo razmotrili rezultate dobivene kod primjera sa vektoriziranim usporednim operatorima onda smo mogli vrlo dobro naslutiti kako radi uvjetno referenciranje. Princip je jednostavan - za indeksni vektor postavljamo logički vektor iste duljine kao i vektor čije elemente želimo dohvatiti. Elementi logičkog vektora određuju koje elemente zadržavamo (pozicije gdje se nalazi vrijednost TRUE) a koje odbacujemo (pozicije gdje se nalazi vrijednost FALSE). Zadatak 3.11 - uvjetno referenciranje x &lt;- 1:10 # napravite logički vektor `y` duljine 10 sa proizvoljnom kombinacijom # vrijednosti TRUE i FALSE # indeksirajte vektor `x` vektorom `y`, ispišite i objasnite rezultat # ispišite sve elemente vektora `x` manje ili jednake 5 # kao logički indeksni vektor upotrijebite odgovarajući izraz # koji koristi usporedni operator x &lt;- 1:10 # napravite logički vektor `y` duljine 10 sa proizvoljnom kombinacijom # vrijednosti TRUE i FALSE y &lt;- c(T, T, F, T, F, F, F, T, F, T) # indeksirajte vektor `x` vektorom `y`, ispišite i objasnite rezultat x[y] # ispišite sve elemente vektora `x` manje ili jednake 5 # kao logički indeksni vektor upotrijebite odgovarajući izraz # koji koristi usporedni operator x[x &lt;= 5] ## [1] 1 2 4 8 10 ## [1] 1 2 3 4 5 Zadnja naredba, naoko jednostavna, predstavlja jedan od ključnih principa odabira elemenata u jeziku R. Kombinacija indeksnog operatora i uvjetnog izraza predstavlja sažet ali vrlo moćan mehanizam rezanja vektora prema odabranom kriteriju. Isprobajmo ovaj princip na još nekoliko primjera. Zadatak 3.12 - uvjetno referenciranje y &lt;- seq(1, 100, 7) studenti &lt;- c(&quot;Ivo&quot;, &quot;Petra&quot;, &quot;Marijana&quot;, &quot;Ana&quot;, &quot;Tomislav&quot;, &quot;Tin&quot;) # ispišite vektor koji sadrži sve parne, a potom sve neparne elemente vektora `y` # ispišite sve elemente vektora `studenti` koji predstavljaju imena od 3 slova # (napomena: za prebrojavanje slova znakovnog niza u R-u koristimo funkciju `nchar`) y &lt;- seq(1, 100, 7) studenti &lt;- c(&quot;Ivo&quot;, &quot;Petra&quot;, &quot;Marijana&quot;, &quot;Ana&quot;, &quot;Tomislav&quot;, &quot;Tin&quot;) # ispišite vektor koji sadrži sve parne, a potom sve neparne elemente vektora `y` c(y[y %% 2 == 0], y[y %% 2 != 0]) # ispišite sve elemente vektora `studenti` koji predstavljaju imena od 3 slova # (napomena: za prebrojavanje slova znakovnog niza u R-u koristimo funkciju `nchar`) studenti[nchar(studenti) == 3] ## [1] 8 22 36 50 64 78 92 1 15 29 43 57 71 85 99 ## [1] &quot;Ivo&quot; &quot;Ana&quot; &quot;Tin&quot; Ukoliko koncept uvjetnog referenciranja uz pomoć uvjetnih izraza i dalje nije jasan, jedna od stvari koje mogu pomoći jest skiciranje “međurezultata” - jednostavno na papir ispišite rezultat izraza unutar uglatih zagrada indeksnog operatora i potom razmislite kako taj rezultat utječe na konačno rješenje. Preostao nam je još samo zadnji tip referenciranja koji radi na principu dohvaćanja elemenata vektora ovisno o njihovom imenu. 3.2.3 Imensko referenciranje Imensko referenciranje radi na principu eksplicitnog imenovanja elemenata koje želimo “zadržati”. Da bi mogli koristiti ovakav tip referenciranja moramo zadovoljiti nužan preduvjet - elementi vektora moraju imati definirana “imena”. Vektori koje smo do sada koristili nisu imali imenovane elemente. Svaki element imao je svoju predefiniranu poziciju unutar vektora te svoju vrijednost, ali nije imao nikakav poseban dodatni identifikator. Programski jezik R dopušta pridavanje imena elementima vektora na vrlo jednostavan način - korištenjem funkcije names, operatora pridruživanja te znakovnog vektora sa odabranim imenima. Moramo voditi računa da vektor imena bude jednake duljine kao originalni vektor! Zadatak 3.13 - imensko referenciranje visine &lt;- c(165, 173, 185, 174, 190) names(visine) &lt;- c(&quot;Marica&quot;, &quot;Pero&quot;, &quot;Josip&quot;, &quot;Ivana&quot;, &quot;Stipe&quot;) # ispišite vektor `visine` # ispišite koliko su visoki Pero i Ivana visine &lt;- c(165, 173, 185, 174, 190) names(visine) &lt;- c(&quot;Marica&quot;, &quot;Pero&quot;, &quot;Josip&quot;, &quot;Ivana&quot;, &quot;Stipe&quot;) # ispišite vektor `visine` visine # ispišite koliko su visoki Pero i Ivana visine[c(&quot;Pero&quot;, &quot;Ivana&quot;)] ## Marica Pero Josip Ivana Stipe ## 165 173 185 174 190 ## Pero Ivana ## 173 174 Vidimo da se imensko referenciranje očekivano svodi na prosljeđivanje odgovarajućeg znakovnog vektora kao parametra referenciranja. (NAPOMENA: Pažljiviji čitatelj uočiti će jednu neobičnu činjenicu u gornjem programskom kodu - poziv funkcije se koristi kao lvalue! Odgovor na pitanje zašto je ovo moguće zahtijeva malo više znanja o internom funkcioniranju jezika R, a za sada je dovoljno reći da se ovdje zapravo radi o pozivu funkcije pravog imena names&lt;- koji se “skriva” iza puno intuitivnije i lako razumljive sintakse) Ukoliko iz nekog razloga poželimo obrisati imena elemenata vektora, jednostavno pozivu funkcije names proslijedimo NULL. names(visine) &lt;- NULL Ovime ćemo zaključiti priču o vektorima. Naučili smo različite načine stvaranja vektora te dohvaćanja i izmjene njegovih elemenata. Sada je vrijeme da pokušamo vektorima dodati dodatnu “dimenziju” - upoznajmo matrice i polja. 3.3 Matrice i polja Matrice i polja su, jednostavno rečeno, višedimenzionalni vektori. Matrica (engl. matrix) je tako vektor sa dvije dimenzije, tj. vektor koji elemente smiješta u “retke” i “stupce”. Polje (engl. array) je vektor sa tri ili više dimenzija. Dok se matrice relativno često koriste u praksi, polja su ipak nešto više ograničena na posebne scenarije. Zbog ove činjenice u ovom poglavlju uglavnom ćemo se baviti matricama, iako se prikazani koncepti vrlo lako poopćuju na polja. Ono što je zajedničko matricama i poljima, a što je poznata činjenica čitateljima sa programerskim iskustvom, jest da je njihova višedimenzionalnost zapravo prividna. I matrice i polja su zapravo jednodimenzionalni vektori kojima je dodan atribut dimenzionalnosti, a uz pomoć tog atributa jezik R mapira naše višedimenzionalno referenciranje u “stvarni” indeks elementa jednodimenzionalnog vektora. Ova činjenica nas ne ograničava - mi i dalje možemo u većini slučajeva tretirati matricu kao da je zaista dvodimenzionalna, a znanje o jednodimenzionalnoj prirodi nam može samo dati dodatnu fleksibilnost u radu s matricama. Postoji nekoliko načina stvaranja nove matrice: uz pomoć funkcije matrix kojoj prosljeđujemo jednodimenzionalni vektor i željeni broj redaka i stupaca kroz parametre nrow i ncol “ručnim” postavljanjem dimenzija jednodimenzionalnog vektora uz pomoć funkcije dim i pridruživanja dvoelementnog numeričkog vektora sa dimenzijama matrice “ljepljenjem” jednodimenzionalnih vektora koji predstavljaju retke ili stupce nove matrice uz pomoć funkcija rbind (engl. row bind) i cbind (engl. column bind) Demonstrirajmo ove načine u primjerima koji slijede. Zadatak 3.14 - funkcija matrix x &lt;- 1:12 # uz pomoć funkcije `matrix` i stvorite matricu sa 3 retka i 4 stupca # koja sadrži elemente vektora `x` # ispišite rezultat na zaslon # ponovite postupak ali pozivu funkcije dodajte parametar `byrow = T` # ispišite rezultat na zaslon i usporedite s prethodnim rezultatom # uz pomoć funkcije `matrix` stvorite matricu sa 3 retka i 4 stupca # koja sadrži elemente vektora `x` # ispišite rezultat na zaslon matrix(x, nrow = 3, ncol = 4) # ponovite postupak ali pozivu funkcije dodajte parametar `byrow = T` # ispišite rezultat na zaslon i usporedite s prethodnim rezultatom matrix(x, nrow = 3, ncol = 4, byrow = T) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Uočite da ga ukoliko eksplicitno ne zamolimo drugačije, R matricu popunjava po stupcima. Ovo je napravljeno zbog sličnosti matrice sa tabličnim prikazom podataka koje najčešće analiziramo gledajući pojedine stupce. No budući da nam je često punjenje po retcima “prirodnije”, ne smijemo zaboraviti na vrlo korisni parametar byrow. Zadatak 3.15 - funkcija dim m &lt;- 1:10 # ispišite rezultat poziva funkcije `dim` nad vektorom `m` # pozivu funkcije `dim` nad vektorom `m` pridružite vektor c(2, 5) # ispišite `m` i komentirajte rezultat # ispišite rezultate poziva funkcija `nrow` i `ncol` nad matricom `m` m &lt;- 1:10 # ispišite rezultat poziva funkcije `dim` nad vektorom `m` dim(m) # pozivu funkcije `dim` nad vektorom `m` pridružite vektor c(2, 5) dim(m) &lt;- c(2, 5) # ispišite `m` i komentirajte rezultat m # ispišite rezultate poziva funkcija `nrow` i `ncol` nad matricom `m` nrow(m) ncol(m) ## NULL ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 ## [1] 2 ## [1] 5 Vidimo da “običan” vektor zapravo nema dimenziju, što se očituje preko NULL vrijednosti koju smo dobili kao rezultat. Pozivom funkcije dim mi vektoru zapravo dodajemo atribut naziva dim čime on formalno postaje matrica (tj. polje u općenitom slučaju). Upravo dimenzije su te koje definiraju kako su elementi složeni po retcima i stupcima a postavljanjem dimenzija moramo biti oprezni da one odgovaraju trenutnom broju elemenata. Jednom kad matrica ima dodane dimenzije, možemo ih dohvatiti “zajedno” uz pomoć funkcije dim, ili samo broj redaka ili stupaca uz pomoć funkcija nrow i ncol. Rezultantna matrica je poput one iz prethodnog primjera popunjena po stupcima. Budući da ovdje nemamo priliku koristiti parametar byrow, jedan od načina da dobijemo matricu popunjenu po retcima jest da transponiramo dobiveni rezultat uz pomoć funkcije t. m &lt;- t(m) # transponiramo matricu i pohranjujemo natrag u varijablu `m` Konačno, matricu možemo stvoriti “ljepljenjem” redaka i stupaca uz pomoć funkcija rbind i cbind. Ovo je također zgodan način dodavanja novih redaka i stupaca postojećoj matrici. Zadatak 3.16 - funkcije rbind i cbind a &lt;- 1:4 b &lt;- 5:8 c &lt;- c(0,0) # stvorite matricu `m` u kojoj će vektori `a` i `b` biti retci # dodajte novi redak na vrh matrice `m` sa elementima vektora `c` # ispišite matricu `m` a &lt;- 1:4 b &lt;- 5:8 c &lt;- c(0,0) # stvorite matricu `m` u kojoj će vektori `a` i `b` biti stupci m &lt;- cbind(a,b) # dodajte novi redak na vrh matrice `m` sa elementima vektora `c` # ispišite matricu `m` m &lt;- rbind(c, m) m ## a b ## c 0 0 ## 1 5 ## 2 6 ## 3 7 ## 4 8 3.3.1 Rezanje matrica Sve naučene principe za “rezanje” vektora uz pomoć indeksnih vektora možemo direktno primijeniti nad matricama. Razlike su sljedeće: referenciramo svaku dimenziju zasebno prvo referenciramo retke, a potom stupce, a indeksne vektore odvajamo zarezom ako želimo “sve retke” ili “sve stupce” taj indeksni vektor jednostavno izostavimo (ali i dalje koristimo zarez) # pretpostavimo da je `m` matrica dimenzija 3 x 5, sa imenima stupaca od `a` do `e` m[1, 2:5] # prvi redak, svi stupci od drugog do petog m[c(F, T, T), c(&quot;a&quot;, &quot;b&quot;)] # drugi i treći redak, stupci `a` i `b` m[,] # svi retci i svi stupci (može i samo `m`) U praksi kod matrica najčešće koristimo lokacijsko i imensko referenciranje; uvjetno referenciranje nije previše praktično zbog dvodimenzionalne prirode matrice (iako je izvedivo, samo moramo voditi računa da logički indeksni vektori duljinom odgovaraju pripadajućoj dimenziji). Jedna od stvari na koju moramo voditi računa jest tendencija jezika R da nam “pomaže” pojednostavljujući rezultat. Tako će rezultat operacije rezanja matrice koja ostavlja samo jedan redak ili stupac automatski postati vektor, tj. izgubiti će atribut dimenzije. Ovo nam nekad ne odgovara, pogotovo ako radimo programske skripte koje u daljnjoj proceduri očekuju matricu, pa makar ona imala dimenziju redaka ili stupaca 1. U tom slučaju kod referenciranja moramo postaviti i dodatni parametar drop = F. Ovo često izgleda dosta nezgrapno, zbog čega danas postoje mnogi paketi proširenja jezika R koji ovo “popravljaju”, tj. koji se trude rezultat ostavljati u konzistentnom obliku. No parametar drop postavljen na FALSE treba imati u vidu, budući da će se pojavljivati i na drugim mjestima u sličnoj funkciji. Zadatak 3.17 - rezanje matrica m &lt;- matrix(1:30, 6, 5, T) colnames(m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # ispišite sve elemente matrice m od drugog do četvrtog retka # te od trećeg do petog stupca # sve elemente u stupcu naziva &quot;c&quot; postavite na nulu # a potom ispišite prva dva retka matrice `m` # ispišite samo stupac &quot;d&quot; # ispišite opet stupac &quot;d&quot;, ali kod referenciranja dodajte parametar `drop = FALSE` # parametar odvojite zarezom (kao da se radi o &quot;trećoj&quot; dimenziji referenciranja) m &lt;- matrix(1:30, 6, 5, T) colnames(m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # ispišite sve elemente matrice `m` od drugog do četvrtog retka # te od trećeg do petog stupca m[2:4, 3:5] # sve elemente u stupcu naziva &quot;c&quot; postavite na nulu # a potom ispišite prva dva retka matrice `m` m[, &quot;c&quot;] &lt;- 0 m[1:2,] # ispišite samo stupac &quot;d&quot; m[, &quot;d&quot;] # ispišite opet stupac &quot;d&quot;, ali kod referenciranja dodajte parametar `drop = FALSE` # parametar odvojite zarezom (kao da se radi o &quot;trećoj&quot; dimenziji referenciranja) m[, &quot;d&quot;, drop = F] ## c d e ## [1,] 8 9 10 ## [2,] 13 14 15 ## [3,] 18 19 20 ## a b c d e ## [1,] 1 2 0 4 5 ## [2,] 6 7 0 9 10 ## [1] 4 9 14 19 24 29 ## d ## [1,] 4 ## [2,] 9 ## [3,] 14 ## [4,] 19 ## [5,] 24 ## [6,] 29 Ovdje ćemo završiti priču o matricama. Ove strukture su vrlo korisne kod rješavanja matematičkih zadataka zasnovanih na matricama, pri čemu je često zgodno pogledati dokumentaciju jezika R kako bi vidjeli koje funkcije i operatori su nam dostupni za takav posao. Isto tako, neki prikazani principi upravljanja matricama biti će korisni kod upravljanja tzv. podatkovnim okvirima - vjerojatno najpopularnijem tipu objekta jezika R kojeg ćemo upoznati u jednom od nastupajućih poglavlja. Konačno, iako se nećemo detaljno baviti poljima, prikažimo radi potpunosti primjer programskog koda koji stvara trodimenzionalno polje te potom ispisuje jedan njegov dio standardnim principom rezanja kojeg smo upoznali kod vektora i matrica. polje &lt;- array(1:24, dim = c(2, 3, 4)) # polje dimenzija 2 x 3 x 4 polje[, 1:2, 3, drop = FALSE] # ispis svih redaka, prvog i drugog stupca # trećeg &quot;sloja&quot;, uz zadržavanje tipa polja 3.4 Liste Lista je element programskog jezika R koji se koristi kao “univerzalni spremnik” bilo kakvih podataka. Za razliku od vektora (tj. od pojma vektora kakvog smo ga inicijalno definirali), lista može sadržavati različite tipove podataka ili - češće - skupove različitih tipova podataka. Listu stvaramo uz pomoć funkcije list kojom dodajemo niz parova naziva elemenata i njihovih sadržaja. Ovi elementi mogu biti bilo što, pa čak i druge liste. mojaLista &lt;- list(a = 1, b = 2:100, c = list(x = 1, y = 2)) Probajmo stvoriti vlastitu listu u sljedećem primjeru. Zadatak 3.18 - stvaranje liste # stvorite novu listu naziva `svastara` koja će imati sljedeće elemente # element naziva `brojevi` sa cijelim brojevima od 1 do 3 # element naziva `slova` sa slovima &quot;A&quot; i &quot;B&quot; # bezimeni element sa logičkim vektorom `c(T,F)` # element naziva `imena` sa imenima &quot;Ivo&quot; i &quot;Ana&quot; # ispišite listu `svastara` svastara &lt;- list(brojevi = c(1,2,3), slova = c(&quot;A&quot;, &quot;B&quot;), c(T,F), imena = c(&quot;Ivo&quot;, &quot;Ana&quot;)) # ispišite listu `svastara` svastara ## $brojevi ## [1] 1 2 3 ## ## $slova ## [1] &quot;A&quot; &quot;B&quot; ## ## [[3]] ## [1] TRUE FALSE ## ## $imena ## [1] &quot;Ivo&quot; &quot;Ana&quot; Uočite da lista zadržava poredak elemenata - element bez imena prikazan je indeksom 3. Funkcija str (engl. structure) omogućuje nam uvid u svojstva i sadržaj liste bez ispisivanja cijele liste. Ovu funkciju analitičari često koriste, kako za pregled lista tako i za brzi uvid u već spomenute podatkovne okvire koje ćemo raditi u idućem poglavlju. Zadatak 3.19 - struktura liste # ispišite strukturu liste `svastara` # ispišite strukturu liste `svastara` str(svastara) ## List of 4 ## $ brojevi: num [1:3] 1 2 3 ## $ slova : chr [1:2] &quot;A&quot; &quot;B&quot; ## $ : logi [1:2] TRUE FALSE ## $ imena : chr [1:2] &quot;Ivo&quot; &quot;Ana&quot; Na početku ove lekcije smo rekli da u R-u vrijedi princip “sve je vektor” te da su vektori zapravo uređeni skupovi elemenata istog tipa. Iz ovog bi se moglo zaključiti da ta činjenica ne vrijedi za liste - oni očito sadržavaju elemente različitih tipova. No pravi odgovor je - i liste su zapravo vektori, a definicija zapravo nije narušena. Naime, svi elementi liste su zapravo male jednoelementne liste, tako da su formalno svi elementi istog tipa. Zadatak 3.20 - tip elemenata liste # ispišite prvi element liste svastara # provjerite njegov tip # ispišite prvi element liste svastara svastara[1] # provjerite njegov tip typeof(svastara[1]) ## $brojevi ## [1] 1 2 3 ## ## [1] &quot;list&quot; Dakle, dokazali smo da su elementi liste zapravo male liste, što se vidi iz ispisa samog elementa, kao i provjere njezinog tipa. Možda nam se čini da bi elementi gore stvorene liste trebali biti vektori, budući da smo listu i stvorili “slaganjem” različitih vektora, no u postupku stvaranja objekta R je “umotao” elemente u jednoelementne liste prije nego ih je uklopio u “veliku” listu. Često ne želimo raditi s elementom liste kao “malom listom”, nego ga trebao u njegovom “originalnom” obliku. Za ovo koristimo operator [[, tj. operator “dvostruke uglate zagrade”. Zadatak 3.21 - operator [[ # ispišite prvi element liste svastara korištenjem operatora `[[` # provjerite njegov tip # ispišite prvi element liste svastara svastara[[1]] # provjerite njegov tip typeof(svastara[[1]]) ## [1] 1 2 3 ## [1] &quot;double&quot; Navedeni operator najčešće koristimo kako bi dohvatili odabrani element liste kojeg definiramo brojem ili (ako ima ime) nazivom elementa. Kod ovakvog dohvata moramo koristiti kombinaciju simbola lista[[&quot;ime_elementa&quot;]] koja je ponešto nespretna za tipkanja. Zbog toga R nudi alternativni način pristupa elementima liste prema nazivu korištenjem operatora $, tj. lista$ime_elementa. Zadatak 3.22 - operator $ # ispišite element naziva &quot;slova&quot; liste svastara # korištenjem operatora `[[` # ispišite isti element korištenjem operatora `$` # ispišite element naziva &quot;slova&quot; liste svastara # korištenjem operatora `[[` svastara[[&quot;slova&quot;]] # ispišite isti element korištenjem operatora `$` svastara$slova ## [1] &quot;A&quot; &quot;B&quot; ## [1] &quot;A&quot; &quot;B&quot; Liste su iznimno popularni tip objekta u R-u budući da predstavljaju univerzalni predložak za kompleksnije podatkovne strukture, između ostalog i kompleksnije objekte u užem smislu (kao što ćemo vidjeti kasnije). Lista je također “temelj” za daleko najpopularniji i najčešće korišteni element jezika R - podatkovni okvir - kojeg ćemo upoznati u idućoj lekciji. Za kraj naučimo dodati element u listu. Ovo je najjednostavnije učiniti korištenjem već spomenutog operatora $ - kao npr. lista$noviElement &lt;- noviElement. Element brišemo tako da mu dodijelimo vrijednost NULL. Zadatak 3.23 - dodavanje elementa u listu # listi `svastara` dodajte element `parniBrojevi` koji sadrži # sve parne brojeve od 1 do 100 # obrišite treći element liste # ispišite listu `svastara` # listi `svastara` dodajte element `parniBrojevi` koji sadrži # sve parne brojeve od 1 do 100 svastara$parniBrojevi &lt;- seq(2, 100, 2) # obrišite treći element liste svastara[[3]] &lt;- NULL # ispišite listu `svastara` print(svastara) ## $brojevi ## [1] 1 2 3 ## ## $slova ## [1] &quot;A&quot; &quot;B&quot; ## ## $imena ## [1] &quot;Ivo&quot; &quot;Ana&quot; ## ## $parniBrojevi ## [1] 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 ## [18] 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 ## [35] 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 U sljedećoj lekciji konačno ćemo upoznati već više puta spominjane podatkovne okvire kao daleko najpopularniji i najčešće korištenu podatkovnu strukturu jezika R. Zadaci za vježbu Stvorite sljedeće vektore: (11, 12, 13,…, 99) (0, 0, 0, 0, … , 0) (100 nula) (0, 0.1, 0.2, …., 1.0) Kolika je suma svih brojeva od 101 do 1001, ako preskočimo sve brojeve djeljive sa 10? Koristite se funkcijom sum. Stvorite matricu 3 x 3 sa brojevima izvođenjem sljedećih naredbi (funkciju sample ćemo pobliže upoznati u jednoj od sljedećih lekcija): # stvaramo matricu 3x3 nasumično odabranih elemenata iz skupa od 1 do 100 set.seed(1234) m &lt;- matrix(c(sample(1:100, 9, T)), nrow = 3, ncol = 3, byrow = T) Izračunajte inverznu matricu uz pomoć funkcije solve. Provjerite da li umnožak originalne i inverzne matrice daje jediničnu matricu (za množenje matrica koristite se operatorom %*%). Inicijalizirajte ponovo listu svastara korištenu u lekciji. Napravite sljedeće: ispišite klasu drugog elementa liste ispišite element na trećem mjestu elementa liste naziva slova provjerite duljinu elementa naziva imena te na zadnje mjesto dodajte ime &quot;Pero&quot; provjerite da li se broj 4 nalazi u prvom elementu liste na zadnje mjesto liste dodajte novu listu sa tri vektora a, b i c koji svi sadrže elemente (1,2,3) Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],
["okviri.html", "4 Podatkovni okviri i faktori 4.1 Podatkovni okviri 4.2 Odabir redaka i stupaca podatkovnih okvira 4.3 Dodavanje i brisanje redaka i stupaca 4.4 Faktori Zadaci za vježbu", " 4 Podatkovni okviri i faktori 4.1 Podatkovni okviri Kao što je već rečeno, podatkovni okvir je daleko najpopularniji element programskog jezika R. Jezik R predviđen je primarno analizi podataka, a podatkovni okvir zapravo predstavlja objektnu reprezentaciju podatkovnog skupa kojeg namjeravamo analizirati. Drugim riječima, podatkovni okvir je objekt slične funkcije kao tablica u Microsoft Excel-u ili relacijskoj bazi podataka. Gotovo svaka “sesija” u R-u svodi se na manipuliranje podatkovnim okvirima - no dok u Excel-u tablicom upravljamo uz pomoć grafičkog sučelja, a u bazi uz pomoć upitnog jezika SQL, u R-u podatkovnim okvirima upravljamo gotovo isključivo programski. Uzmimo za primjer sljedeću tablicu: pbr nazivMjesta prosjPlacaKn brojStanovnika prirez 10000 Zagreb 6359.00 790017 18 51000 Rijeka 5418.00 128384 15 21000 Split 5170.00 167121 10 31000 Osijek 4892.00 84104 13 20000 Dubrovnik 5348.00 28434 10 Ovdje se radi o podatkovnom skupu koji sadržava određene parametre vezane uz gradove u Republici Hrvatskoj (navedene vrijednosti ne odgovaraju nužno trenutnom stanju već ih koristimo samo za demonstraciju). Lako možemo zamisliti kako ove podatke zapisujemo u Excel ili stvaramo relacijsku tablicu naziva npr. MJESTO u koju onda pohranjujemo navedene podatke. Pokažimo sada kako bi sa istim podacima manipulirati u sklopu jezika R, tj. pokušajmo stvoriti podatkovni okvir koji će sadržavati ove podatke. U prošloj lekciji smo napomenuli da je lista kao složeni tip zapravo svojevrsni “predložak” uz pomoć kojeg možemo raditi nove objekte. Podatkovni okvir tako zapravo nije ništa drugo nego lista – tj. “spremnik” koji može sadržavati u sebi druge spremnike podataka različitog tipa. No dok je “lista“ zapravo univerzalni spremnik, tj. nemamo ograničenja što”trpamo&quot; u nju, podatkovni okvir ima određene restrikcije. Najvažnije ograničenje koje podatkovni okvir nameće jest da svaki element unutar podatkovnog okvira mora imati isti broj elemenata. Zašto je tome tako? Zamislimo listu u kojoj svaki element ima isti broj podelemenata. Ako svaki element skiciramo vertikalno, sa podelementima napisanim jedan ispod drugog, onda će ti podelementi biti “poravnati” po retcima čime smo postigli klasičnu organizaciju podataka u stupce (elemente liste) i retke (poravnati podelementi). Dakle, ova restrikcija zapravo direktno nameće “tabličnu” ili “matričnu” strukturu liste sa jasno definiranim retcima i stupcima, što nam zapravo omogućuje da podatkovnim okvirom upravljamo i uz pomoć metoda vezanih uz liste, ali i uz pomoć metoda primarno namijenjenih matricama. Postoji više načina stvaranja podatkovnih okvira, a mi ćemo prikazati dva u praksi najčešće susretana scenarija: programsko stvaranje uz pomoć funkcije data.frame učitavanje podataka iz vanjskog izvora uz pomoć funkcije read.csv Prikažimo oba slučaja. Prvo ćemo stvoriti podatkovni okvir programski. Zadatak 4.1 - programsko stvaranje podatkovnog okvira pbr = c(10000, 51000, 21000, 31000, 2000) nazivMjesta = c(&quot;Zagreb&quot;, &quot;Rijeka&quot;, &quot;Split&quot;, &quot;Osijek&quot;, &quot;Dubrovnik&quot;) prosjPlacaKn = c(6359., 5418., 5170., 4892., 5348.) brojStanovnika = c(790017, 128384, 167121, 84104, 28434) prirez = c(18, 15, 10, 13, 10) # uz pomoć funkcije `data.frame` i gornjih vektora stvorite podatkovni okvir `mjesto` # koristite istu sintaksu kao kod stvaranja liste # elemente liste nazovite imenima varijabli # ispišite podatkovni okvir `mjesto` pbr = c(10000, 51000, 21000, 31000, 2000) nazivMjesta = c(&quot;Zagreb&quot;, &quot;Rijeka&quot;, &quot;Split&quot;, &quot;Osijek&quot;, &quot;Dubrovnik&quot;) prosjPlacaKn = c(6359., 5418., 5170., 4892., 5348.) brojStanovnika = c(790017, 128384, 167121, 84104, 28434) prirez = c(18, 15, 10, 13, 10) # uz pomoć funkcije `data.frame` i gornjih vektora stvorite podatkovni okvir `mjesto` # koristite istu sintaksu kao kod stvaranja liste # elemente liste nazovite imenima varijabli mjesto &lt;- data.frame( pbr = pbr, nazivMjesta = nazivMjesta, prosjPlacaKn = prosjPlacaKn, brojStanovnika = brojStanovnika, prirez = prirez) # ispišite podatkovni okvir `mjesto` mjesto ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 2000 Dubrovnik 5348 28434 10 Ukoliko želite, pokušajte ponovo stvoriti gornji podatkovni okvir ali uz različite brojeve elemenata vektora koji čine stupce. Ova operacija rezultirati će greškom uz prikladnu poruku a podatkovni okvir neće biti stvoren - R se trudi da matrična priroda okvira uvijek bude očuvana. Mala napomena glede terminologije: u nastavku ćemo zbog jednostavnosti “podatkovni okvir” često zvati jednostavno “okvir” ili “tablica”. Isto tako, često ćemo za elemente podatkovnog okvira jednakopravno koristiti izraze “stupac”, “varijabla” ili “atribut”, dok ćemo paralelne podelemente elemenata okvira nazivati “retcima” ili “obzervacijama”. Ovi termini u skladu su sa standardnim načinom referenciranja elemenata tablice te statističkim terminima koji se odnose na tablične podatkovne skupove. Ukoliko iz konteksta postoji šansa za dvosmislenost, koristiti će se onaj termin koji jasno opisuje element koji se referencira. Pokušajmo sada učitati tablicu iz vanjskog izvora. Iako R dopušta različite oblike “vanjskih” podataka, mi ćemo pretpostaviti da podatke dobivamo u tzv. “CSV obliku” (engl. CSV - comma-separated values). Ovaj oblik jedan je od najpopularnijih načina pohrane podataka u čistom tekstualnom obliku koji ima prednosti da se lako izrađuje ručno, a većina alata za upravljanje podacima implementira i logiku za izvoz podataka u obliku CSV datoteke. U nastavku možemo vidjeti primjer CSV datoteke koja odgovara podatkovnom okviru izrađenom u prethodnom primjeru. Pretpostavimo da se datoteka zove mjesto.csv. Podaci su odvojeni zarezom (bez razmaknice!), svaka obzervacija u svojem retku, a opcionalni prvi redak predstavlja nazive stupaca. pbr,nazivMjesta,prosjPlacaKn,brojStanovnika,prirez 10000,Zagreb,6359.00,790017,18 51000,Rijeka,5418.00,128384,15 21000,Split,5170.00,167121,10 31000,Osijek,4892.00,84104,13 20000,Dubrovnik,5348.00,28434,10 Jedan od potencijalnih problema sa CSV datotekama jest taj što one koriste zarez kao razdvojnik (delimiter) elemenata zapisa, a na određenim govornim područjima kao standard se umjesto decimalne točke koristi upravo “decimalni zarez”. Zbog ove činjenice postoji i “alternativni” CSV standard koji kao razdvojnik koristi “točku-zarez”, tako da bi naša CSV datoteka u tom slučaju izgledala ovako (nazovimo ju mjestoAlt.csv): pbr;nazivMjesta;prosjPlacaKn;brojStanovnika;prirez 10000;Zagreb;6359,00;790017;18 51000;Rijeka;5418,00;128384;15 21000;Split;5170,00;167121;10 31000;Osijek;4892,00;84104;13 20000;Dubrovnik;5348,00;28434;10 Obzirom da je “decimalni zarez” propisani standard i na području Republike Hrvatske, u radu sa CSV datotekama moramo biti oprezni koji od dva standarda zapisa se koristi. Na sreću, jezik R nudi funkcije za podršku oba standarda, tako da ne moramo posebno prilagođavati ulazne datoteke, tek biti oprezni koju funkciju ćemo odabrati. Pretpostavimo da u radnoj mapi imamo ove dvije datoteke: mjesto.csv mjestoAlt.csv Ukoliko nemamo dostupne ove datoteke lako ih možemo samostalno napraviti uz pomoć običnog uređivača teksta (npr. Notepad ili gedit) i kopiranja gore navedenih redaka. Za stvaranje podatkovnih okvira iz CSV datoteka koristimo funkcije: - read.csv - za “normalne” CSV datoteke sa zarezom kao razdvojnikom - read.csv2 - za alternativni CSV standard koji koristi točku-zarez Osnovni parametar ovih funkcija je staza do CSV datoteke koju učitavamo. Funkcije imaju i bogati niz dodatnih parametara koje omogućuju prilagodbu raznim scenarijima, a ukoliko smo dobili neki od “egzotičnijih” oblika CSV datoteke, isplati se pogledati i funkciju read.table koja je vrlo fleksibilna glede broja različitih parametara i postavki kod učitavanja podataka (read.csv i read.csv2 su zapravo izvedene iz funkcije read.table fiksiranjem određenih parametara na standardne CSV značajke). Neke od parametara i pripadajućih vrijednosti funkcija read.csv (ili read.table) koje je korisno znati su: header = FALSE - za datoteke bez zaglavlja sep = &quot;#&quot; - za datoteke koje koriste “egzotični” razdvojnik, u ovom slučaju # na.strings = &quot;NULL&quot; - naznaka koji standard podaci koriste za reprezentaciju nedostajućih vrijednosti a koji će u R-u postati NA nrows = 2000 - maksimalan broj redaka koji će se pročitati, u ovom slučaju 2000 stringsAsFactors = F - sprječavanje automatskog stvaranja faktorskih stupaca (o kojima ćemo učiti u nastavku ove lekcije) encoding = &quot;UTF-8&quot; - za standarde kodiranja teksta koji nisu ASCII (osobito bitno ako radimo sa podacima sa hrvatskog govornog područja koji koriste dijakritičke znakove) Pokušajmo sada učitati podatke iz dostupnih CSV datoteka. Ovi podaci neće zahtijevati posebne parametre te će se moći učitati samo pružanjem staze do pripadnih datoteka (jedne koja koristi zarez i druge koja koristi točku-zarez kao razdvojnik). Zadatak 4.2 - čitanje podataka iz CSV datoteke # učitajte podatke iz datoteka `mjesto.csv` i `mjestoAlt.csv` # podatke spremite u okvire `mjesto2` i `mjesto3` # ispišite okvire `mjesto2` i `mjesto3` # učitajte podatke iz datoteka `mjesto.csv` i `mjestoAlt.csv` # podatke spremite u okvire `mjesto2` i `mjesto3` mjesto2 &lt;- read.csv(&quot;mjesto.csv&quot;) mjesto3 &lt;- read.csv2(&quot;mjestoAlt.csv&quot;) # ispišite okvire `mjesto2` i `mjesto3` mjesto2 cat(&quot;-----------\\n&quot;) mjesto3 ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 20000 Dubrovnik 5348 28434 10 ## ----------- ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 20000 Dubrovnik 5348 28434 10 Pogledajmo sada neke korisne funkcije za rad sa podatkovnim okvirima tj. tablicama. Dobar dio njih će nam već otprije biti poznat iz iskustva u radu sa listama i matricama: nrow - broj redaka ncol ili length - broj stupaca (budući da se okvir ponaša i kao matrica i kao lista) dim - dimenzije tablice names - imena stupaca head - ispis nekoliko redaka s početka tablice tail - ispis nekoliko redaka s kraja tablice str - ispis strukture tablice summary - sažete statističke informacije o stupcima tablice Isprobajmo neke od ovih funkcija: Zadatak 4.3 - funkcije za rad sa podatkovnim okvirima # ispišite dimenzije tablice `mjesto` # ispišite strukturu tablice `mjesto` # ispišite prvih nekoliko redaka tablice `mjesto` # ispišite sažete statističke informacije o stupcima tablice `mjesto` # ispišite dimenzije tablice `mjesto` dim(mjesto) cat(&quot;-----------\\n&quot;) # ispišite strukturu tablice `mjesto` str(mjesto) cat(&quot;-----------\\n&quot;) # ispišite prvih nekoliko redaka tablice `mjesto` head(mjesto) cat(&quot;-----------\\n&quot;) # ispišite sažete statističke informacije o stupcima tablice `mjesto` summary(mjesto) ## [1] 5 5 ## ----------- ## &#39;data.frame&#39;: 5 obs. of 5 variables: ## $ pbr : num 10000 51000 21000 31000 2000 ## $ nazivMjesta : Factor w/ 5 levels &quot;Dubrovnik&quot;,&quot;Osijek&quot;,..: 5 3 4 2 1 ## $ prosjPlacaKn : num 6359 5418 5170 4892 5348 ## $ brojStanovnika: num 790017 128384 167121 84104 28434 ## $ prirez : num 18 15 10 13 10 ## ----------- ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 2000 Dubrovnik 5348 28434 10 ## ----------- ## pbr nazivMjesta prosjPlacaKn brojStanovnika ## Min. : 2000 Dubrovnik:1 Min. :4892 Min. : 28434 ## 1st Qu.:10000 Osijek :1 1st Qu.:5170 1st Qu.: 84104 ## Median :21000 Rijeka :1 Median :5348 Median :128384 ## Mean :23000 Split :1 Mean :5437 Mean :239612 ## 3rd Qu.:31000 Zagreb :1 3rd Qu.:5418 3rd Qu.:167121 ## Max. :51000 Max. :6359 Max. :790017 ## prirez ## Min. :10.0 ## 1st Qu.:10.0 ## Median :13.0 ## Mean :13.2 ## 3rd Qu.:15.0 ## Max. :18.0 4.2 Odabir redaka i stupaca podatkovnih okvira Već smo rekli da se podatkovni okviri ponašaju i kao matrice i kao liste, što je svojstvo kojim se posebno često služimo kod odabira redaka i stupaca podatkovnih okvira. Konkretno, za “rezanje” okvira najčešće koristimo: dvodimenzionalno referenciranje uz pomoć indeksnih vektora odabir pojedinog stupca uz pomoć operatora $ Ovdje smo zapravo dosta fleksibilni - možemo npr. prvo “izrezati” određene retke matrice uz pomoć lokacijskog referenciranja i potom izdvojiti samo jedan stupac uz pomoć operatora $. U praksi je jedna od najčešćih kombinacija uvjetni odabir redaka uz imenski odabir stupaca (poznavatelji SQL-a prepoznati će ovo kao standardnu kombinaciju WHERE uvjeta i SELECT liste). Pokušajmo primijeniti naše znanje o indeksnim vektorima, matricama i listama na rezanje podatkovnih okvira. Zadatak 4.4 - rezanje podatkovnih okvira # ispišite tablicu `mjesto` (za referencu) # ispišite prva tri retka, treći i peti stupac # ispišite stupac &quot;prirez&quot; # ispišite poštanske brojeve i nazive svih mjesta koja # imaju prirez veći od 12% i broj stanovnika veći od 100,000 #ispišite tablicu `mjesto` (za referencu) mjesto cat(&quot;-----------\\n&quot;) #ispišite prva tri retka, treći i peti stupac mjesto[1:3, c(3,5)] cat(&quot;-----------\\n&quot;) #ispišite stupac &quot;prirez&quot; mjesto$prirez cat(&quot;-----------\\n&quot;) #ispišite poštanske brojeve i nazive svih mjesta koji imaju # prirez veći od 12% i broj stanovnika veći od 100,000 mjesto[mjesto$prirez &gt; 12 &amp; mjesto$brojStanovnika &gt; 100000, c(&quot;pbr&quot;, &quot;nazivMjesta&quot;)] ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 2000 Dubrovnik 5348 28434 10 ## ----------- ## prosjPlacaKn prirez ## 1 6359 18 ## 2 5418 15 ## 3 5170 10 ## ----------- ## [1] 18 15 10 13 10 ## ----------- ## pbr nazivMjesta ## 1 10000 Zagreb ## 2 51000 Rijeka Uočite sličnost između zadnjeg izraza i SQL upita: ` SELECT pbr, nazivMjesta FROM mjesto WHERE mjesto.prirez &gt; 12 AND mjesto.brojStanovnika &gt; 100000 Odabir stupaca i redaka nije težak ako dobro baratamo znanjem o indeksnim vektorima, no kao što se vidi u zadnjem primjeru sintaksa često nije previše čitljiva (u usporedbi sa npr. SQL-ovom sintaksom koja obavlja isti posao). Zbog toga postoje različita proširenja R-a koji ovaj posao uvelike olakšavaju, a koja ćemo detaljno obraditi u jednoj od budućih lekcija koja će se baviti upravljanjem podatkovnim skupovima. 4.3 Dodavanje i brisanje redaka i stupaca Za dodavanje i brisanje redaka i stupaca opet se dovoljno sjetiti da je podatkovni okvir svojevrsni hibrid matrice i liste tj. ako znamo dodavati retke i stupce u matricu ili nove elemente u listu onda ekvivalentnim načinom možemo podatke dodavati i u podatkovni okvir. U radu sa podatkovnim okvirima nešto češće dodajemo nove stupce (obično kao transformacije postojećih stupaca) nego retke tako da možemo primjere započeti sa dodavanjem stupaca. Kao što je rečeno, stupce u podatkovni okvir dodajemo na isti način kao što dodajemo elemente liste - uz pažnju da dodani stupac ima isti broj elemenata kao i ostali stupci. Novi stupci često su izvedenice postojećih stupaca koje predstavljaju binarne indikatore, rezultate aritmetičkih izraza podataka u drugim stupcima i sl. Zadatak 4.5 - dodavanje novih stupaca u tablicu # tablici `mjesto` dodajte logički stupac `visokPrirez` # koji će pokazivati da li je prirez veći od 12% # pretpostavimo sljedeći (fiktivni!) način izračuna prireza # - mjesta imaju oko 60% radne populacije # - svaki radnik plaća porez koji je otprilike jednak 10% neto plaće # - prirez kojeg radnik plaća računamo kao (stopa prireza)*(iznos poreza) # # dodajte stupac `mjesecniPrihod` koji će uz pomoć prosječne plaće, prireza # i broja stanovnika procijeniti koliki prihod pojedino mjesto dobija od prireza # (izraženo u milijunima Kn) # iznos zaokružite uz pomoć funkcije round ( primjer: round(100.12345, 2) ==&gt; 100.12 ) # ispišite tablicu mjesto # tablici `mjesto` dodajte logički stupac `visokPrirez` # koji će pokazivati da li je prirez veći od 12% mjesto$visokPrirez &lt;- mjesto$prirez &gt; 12 # pretpostavimo sljedeći (fiktivni!) način izračuna prireza # - mjesta imaju oko 60% radne populacije # - svaki radnik plaća porez koji je otprilike jednak 10% neto plaće # - prirez kojeg radnik plaća računati ćemo (stopa prireza)*(iznos poreza) # # dodajte stupac `mjesecniPrihod` koji će uz pomoć prosječne plaće, prireza # i broja stanovnika procijeniti koliki prihod pojedino mjesto dobija od prireza # (izraženo u milijunima Kn) # iznos zaokružite uz pomoć funkcije round ( primjer: round(100.12345, 2) ==&gt; 100.12 ) mjesto$mjesecniPrihod &lt;- round(0.6 * mjesto$brojStanovnika * 0.1 * mjesto$prosjPlacaKn * 0.01 * mjesto$prirez / 1e6 , 2) # ispišite tablicu mjesto mjesto ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez visokPrirez ## 1 10000 Zagreb 6359 790017 18 TRUE ## 2 51000 Rijeka 5418 128384 15 TRUE ## 3 21000 Split 5170 167121 10 FALSE ## 4 31000 Osijek 4892 84104 13 TRUE ## 5 2000 Dubrovnik 5348 28434 10 FALSE ## mjesecniPrihod ## 1 54.26 ## 2 6.26 ## 3 5.18 ## 4 3.21 ## 5 0.91 Retke i stupce smo također mogli dodati slično dodavanju redaka i stupaca u matricu - uz pomoć funkcija rbind i cbind. Kod funkcije rbind obično dodajemo novi podatkovni okvir sa retcima koji imaju odgovarajući redoslijed i vrstu elemenata, dok kod funkcije cbind možemo dodati i obični vektor no moramo paziti da broj elemenata odgovara broju redaka originalnog okvira. Isprobajmo ove funkcije na malim “umjetnim” podatkovnim okvirima kako bi lakše predočili njihovu funkcionalnost. Zadatak 4.6 - funkcije rbind/cbind i podatkovni okviri df1 &lt;- data.frame(a = c(1,2,3), b = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), c = c(T, F, T)) df2 &lt;- data.frame(a = 1, b = &quot;A&quot;, c = 3) #spojite df1 i df2 u podatkovni okvir df12 uz pomoć funkcije `rbind` # okviru df12 dodajte stupac `imena` sa imenima Ivo, Ana, Pero i Stipe # koristite funkciju `cbind` # ispišite okvir df12 df1 &lt;- data.frame(a = c(1,2,3), b = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), c = c(T, F, T)) df2 &lt;- data.frame(a = 1, b = &quot;A&quot;, c = 3) #spojite df1 i df2 u podatkovni okvir df12 uz pomoć funkcije `rbind` df12 &lt;- rbind(df1, df2) # okviru df12 dodajte stupac `imena` sa imenima Ivo, Ana, Pero i Stipe # koristite funkciju `cbind` df12 &lt;- cbind(df12, imena = c(&quot;Ivo&quot;, &quot;Ana&quot;, &quot;Pero&quot;, &quot;Stipe&quot;)) # ispišite okvir df12 df12 ## a b c imena ## 1 1 A 1 Ivo ## 2 2 B 0 Ana ## 3 3 C 1 Pero ## 4 1 A 3 Stipe Za brisanje redaka i stupaca također se možemo koristiti istim metodama za upravljanje matricama i listama. Konkretno: brisanje redaka i stupaca možemo obaviti dvodimenzionalnim referenciranjem redaka i stupaca koje želimo “zadržati” brisanje stupaca možemo obaviti pridjeljivanjem vrijednosti NULL odabranom stupcu Isprobajmo ovo na primjeru. Zadatak 4.7 - brisanje redaka i stupaca # obrišite prvi redak i drugi stupac iz df12 metodom 2d referenciranja # obrišite stupac `imena` uz pomoć pridjeljivanja `NULL` vrijednosti # ispišite df12 # obrišite prvi redak i drugi stupac iz df12 metodom 2d referenciranja df12 &lt;- df12[-1, -2] # obrišite stupac `imena` uz pomoć pridjeljivanja `NULL` vrijednosti df12$imena &lt;- NULL # ispišite df12 df12 ## a c ## 2 2 0 ## 3 3 1 ## 4 1 3 Podatkovnim okvirima ćemo se nastaviti baviti u poglavlju o upravljanju podatkovnim skupovima, gdje ćemo naučiti kako raditi sa okvirima sa daleko više podataka od primjera koje smo koristili u ovoj lekciji, te kako raditi sa dodatnim paketima koji značajno olakšavaju česte radnje nad podacima u podatkovnim okvirima. U nastavku ćemo se pozabaviti još jednim novim (i ponešto kontroverznim) tipom podatkovne strukture. 4.4 Faktori Faktor u R-u je zapravo tip podataka koji predstavlja ono onoga što se u statistici naziva nominalnom ili kategorijskom varijablom. Naime, atribut neke obzervacije često poprima neku vrijednost iz skupa otprije poznatih kategorija (npr. varijabla spola, dobne kategorije, obrazovanja, mjesta rođenja, stranačke preferencije i sl.). Kategorije se često identificiraju jedinstvenim nizom znakova, a u procesu analize uz pomoć njih često provodimo razna agregiranja i grupacije (npr. u nekoj utrci možemo gledati prosječno vrijeme ovisno o spolu ili dobnoj kategoriji) ili pak dijelimo skup podataka ovisno o kategorijskoj pripadnosti. Faktori u R-u su često i predmet rasprava budući da se radi o konstruktu koji može olakšati rad nad podacima, ali i uzrokovati brojne probleme, pogotovo ako nismo svjesni da u nekom trenutku radimo sa faktorom (ovaj scenarij se zapravo vrlo lako izbjegava, što ćemo objasniti na kraju ovog poglavlja). Za početak ćemo predočiti što su zapravo faktori uz pomoć jednostavnog primjera. Zamislimo da sljedeći znakovni vektor opisuje razinu krvnog tlaka kod deset pacijenata: tlak &lt;- c(&quot;nizak&quot;, &quot;visok&quot;, &quot;visok&quot;, &quot;normalan&quot;, &quot;normalan&quot;, &quot;nizak&quot;, &quot;visok&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;normalan&quot;) Ovo je očito “kategorijska” varijabla budući da može poprimiti jednu od tri diskretne vrijednosti - &quot;nizak&quot;, &quot;normalan&quot; i &quot;visok&quot;. Prema tome, ovaj vektor je tipičan kandidat za “faktoriziranje”, tj. za pretvorbu u objekt klase factor. Faktorizaciju znakovnog vektora provodimo uz pomoć funkcije factor kojoj prosljeđujemo (u pravilu) znakovni vektor kao parametar. Zadatak 4.8 - faktoriziranje znakovnog vektora tlak &lt;- c(&quot;nizak&quot;, &quot;visok&quot;, &quot;visok&quot;, &quot;normalan&quot;, &quot;normalan&quot;, &quot;nizak&quot;, &quot;visok&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;normalan&quot;) # ispišite varijablu `tlak` # ispišite klasu varijable `tlak` # stvorite varijablu `tlak.f` koja će biti faktorizirana # inačica varijable `tlak` # ispišite varijablu `tlak.f` # ispišite klasu varijable tlak.f tlak &lt;- c(&quot;nizak&quot;, &quot;visok&quot;, &quot;visok&quot;, &quot;normalan&quot;, &quot;normalan&quot;, &quot;nizak&quot;, &quot;visok&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;normalan&quot;) # ispišite varijablu `tlak` tlak # ispišite klasu varijable `tlak` class(tlak) # stvorite varijablu `tlak.f` koja će biti faktorizirana # inačica varijable `tlak` tlak.f &lt;- factor(tlak) cat(&quot;-----------\\n&quot;) # ispišite varijablu `tlak.f` tlak.f # ispišite klasu varijable tlak.f class(tlak.f) ## [1] &quot;nizak&quot; &quot;visok&quot; &quot;visok&quot; &quot;normalan&quot; &quot;normalan&quot; &quot;nizak&quot; ## [7] &quot;visok&quot; &quot;nizak&quot; &quot;normalan&quot; &quot;normalan&quot; ## [1] &quot;character&quot; ## ----------- ## [1] nizak visok visok normalan normalan nizak visok ## [8] nizak normalan normalan ## Levels: nizak normalan visok ## [1] &quot;factor&quot; Vidimo da je ispis faktora dobio dodatni atribut Levels. To znači da se sada ovdje radi o “pravoj” kategorijskoj varijabli sa točno definiranim kategorijama koje smije poprimiti. Ako pokušamo dodati novu vrijednost u faktor koja nije zastupljena u trenutnim kategorijama (npr. “prenizak”) dobiti ćemo upozorenje, a umjesto kategorije koju smo naveli nova stavka imati će vrijednost NA. Ovo ponekad nije scenarij kojeg priželjkujemo. Ukoliko unaprijed znamo da znakovni vektor kojeg kategoriziramo ne sadrži sve moguće kategorije koje se općenito mogu pojaviti, imamo opciju dodavanja parametra levels u kojem ćemo uz pomoć znakovnog vektora eksplicitno navesti niz “mogućih” kategorija. Zadatak 4.9 - nezastupljene kategorije i parametar levels # dodajte 11. element u vektor `tlak.f` sa sadržajem &quot;prenizak&quot; # ispišite `tlak.f` # napravite varijablu `tlak.f2` uz pomoć varijable `tlak` # kategorijske razine navedite eksplicitno tako da sadrže # i kategorije &quot;prenizak&quot; i &quot;previsok&quot; # dodajte 11. element u vektor `tlak.f2` sa sadržajem &quot;prenizak&quot; # ispišite `tlak.f2` # dodajte 11. element u vektor `tlak.f` sa sadržajem &quot;prenizak&quot; tlak.f[11] &lt;- &quot;prenizak&quot; ## Warning in `[&lt;-.factor`(`*tmp*`, 11, value = &quot;prenizak&quot;): invalid factor ## level, NA generated # ispišite `tlak.f` tlak.f cat(&quot;-----------\\n&quot;) # napravite varijablu `tlak.f2` uz pomoć varijable `tlak` # kategorijske razine navedite eksplicitno tako da sadrže # i kategorije &quot;prenizak&quot; i &quot;previsok&quot; tlak.f2 &lt;- factor(tlak, levels = c(&quot;prenizak&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;visok&quot;, &quot;previsok&quot;)) # dodajte 11. element u vektor `tlak.f2` sa sadržajem &quot;prenizak&quot; tlak.f2[11] &lt;- &quot;prenizak&quot; # ispišite `tlak.f2` tlak.f2 ## [1] nizak visok visok normalan normalan nizak visok ## [8] nizak normalan normalan &lt;NA&gt; ## Levels: nizak normalan visok ## ----------- ## [1] nizak visok visok normalan normalan nizak visok ## [8] nizak normalan normalan prenizak ## Levels: prenizak nizak normalan visok previsok Koja je prednost faktora? Zašto varijable ne bismo ostavili u originalnom, “znakovnom” obliku? Razlog potrebe za faktoriziranjem kategorijskih stupaca tj. varijabli je poglavito u tome što određene statističke i vizualizacijske funkcije “znaju” na ispravan način interpretirati i koristiti faktore te ih tretiraju drugačije od običnih “znakovnih” stupaca. Zbog toga je vrlo dobra dugoročna strategija već u početku učenja R-a naviknuti se da kod rada sa podatkovnim okvirima faktoriziramo stupce koji su zaista kategorijske varijable (ali također i pripazimo da nemamo faktorizirane stupce koji nisu kategorijske varijable, što se može događati ako nismo pažljivi). Jedno od pitanja koje se često pitamo vezano uz kategorijske varijable jest - kolika je zastupljenost pojedinih kategorija? Odgovor na ovo pitanje daje nam funkcija table kojoj prosljeđujemo odabrani faktor. Zadatak 4.10 - funkcija table # ispišite zastupljenost pojedinih kategorija u faktoru `tlak.f2` # ispišite zastupljenost pojedinih kategorija u faktoru `tlak.f2` table(tlak.f2) ## tlak.f2 ## prenizak nizak normalan visok previsok ## 1 3 4 3 0 Funkcija table ne zahtijeva nužno faktor i uredno će raditi čak i sa znakovnim vektorom. No u tom slučaju ne bismo dobili informaciju o kategorijama koje nisu uopće zastupljene. Kategorijska varijabla iz naših primjera zapravo ima prirodu tzv. ordinalne kategorijske varijable, što znači da kategorije imaju prirodni poredak (nizak tlak je “manji” od normalnog koji je “manji” od visokog). Ukoliko želimo, ovu činjenicu možemo “ugraditi” u faktor kod njegove inicijalizacije, jednostavnim dodavanjem parametra ordered postavljenog na TRUE. Prednost ordinalnog faktora jest ta što nam omogućuje usporedbu vrijednosti faktora uz pomoć usporednih operatora. Zadatak 4.11 - ordinalni faktor # napravite varijablu `tlak.f3` na isti način kao i `tlak.f2` # ali uz dodatni parametar `ordered = TRUE` # pripazite da poredak kategorija odgovara ordinalnom rasporedu # ispišite `tlak.f3` # provjerite radi li se uistinu o ordinalnom faktoru # uz pomoć funkcije `is.ordered` # provjerite da li je tlak prvog pacijenta # (okvirno) niži od tlaka trećeg pacijenta # napravite varijablu `tlak.f3` na isti način kao i `tlak.f2` # ali uz dodatni parametar `ordered = TRUE` # pripazite da poredak kategorija odgovara ordinalnom rasporedu tlak.f3 &lt;- factor(tlak, levels = c(&quot;prenizak&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;visok&quot;, &quot;previsok&quot;), ordered = TRUE) # ispišite `tlak.f3` tlak.f3 # provjerite radi li se uistinu o ordinalnom faktoru # uz pomoć funkcije `is.ordered` is.ordered(tlak.f3) # provjerite da li je tlak prvog pacijenta # (okvirno) niži od tlaka trećeg pacijenta tlak.f3[1] &lt; tlak.f3[3] ## [1] nizak visok visok normalan normalan nizak visok ## [8] nizak normalan normalan ## Levels: prenizak &lt; nizak &lt; normalan &lt; visok &lt; previsok ## [1] TRUE ## [1] TRUE Već smo uvidjeli da je u R-u zapravo “sve vektor” - brojevi su jednodimenzionalni numerički vektori, matrice su vektori sa dodanim parametrom dimenzionalnosti, liste su vektori malih listi, podatkovni okviri su liste za dodanom restrikcijom. Možemo se zapitati - što su zapravo faktori? Implementacijski, faktor je zapravo kodirani ili enumerirani skup vrijednosti inicijalno definiranih znakovnih nizova, uz pridruženu kodnu tablicu istih. Jednostavnije rečeno, faktorizacija znakovnog vektora uključuje: “popisivanje” svih uočenih kategorija (ili preuzimanje eksplicitnog popisa iz parametra levels) pridjeljivanje numeričkih vrijednosti redom svakoj kategoriji (npr: &quot;nizak&quot; -&gt; 1, &quot;normalan&quot; -&gt; 2 itd.) “pakiranje” novostvorenog numeričkog vektora i pripadajuće “kodne tablice” Iako ove korake R radi automatski, u internu strukturu faktora možemo se uvjeriti ako faktor probamo pretvoriti u čisti numerički, odnosno čisti znakovni tip. Zadatak 4.12 - interna struktura faktora # ispišite vrijednost varijable tlak.f3 pretvorene u znakovni tip # ispišite vrijednost varijable tlak.f3 pretvorene u numerički tip # ispišite vrijednost varijable tlak.f3 pretvorene u znakovni tip as.character(tlak.f3) # ispišite vrijednost varijable tlak.f3 pretvorene u numerički tip as.numeric(tlak.f3) ## [1] &quot;nizak&quot; &quot;visok&quot; &quot;visok&quot; &quot;normalan&quot; &quot;normalan&quot; &quot;nizak&quot; ## [7] &quot;visok&quot; &quot;nizak&quot; &quot;normalan&quot; &quot;normalan&quot; ## [1] 2 4 4 3 3 2 4 2 3 3 Pretvaranjem faktora u znakovni tip zapravo radimo operaciju inverznu faktoriziranju, tj. dobijamo originalni znakovni vektor. S druge strane pretvaranjem faktora u numerički tip zapravo dobivamo “prekodirane” brojke koje faktor interno koristi za reprezentaciju kategorija. Možemo se zapitati - zašto bi nam ovo bilo korisno? Odgovor je - ne, od ovog u praksi nema neke direktne koristi. Zapravo je ovo nešto što nam može stvoriti vrlo velike probleme ako to unaprijed ne očekujemo. Ovdje se krije već prije navedena “kontroverza” oko faktora kao tipa podataka. Ona zapravo uopće nije povezana sa samim faktorima, već sa nekim nazivnim postavkama R-a i njegovim funkcijama učitavanja podataka iz vanjske datoteke. Navedimo sada detaljne korake koji se odvijaju tijekom stvaranja podatkovnog okvira iz datoteke i pokušajmo zaključiti gdje nastaje potencijalni problem: R otvara CSV datoteku na osnovu pročitanih podataka R pokušava zaključiti kojeg je tipa koji stupac svi znakovni stupci se automatski faktoriziraju osim ako nije naveden parametar stringsAsFactors - FALSE Formira se konačni podatkovni okvir Vidimo li mogući problem? Pretpostavimo sljedeći scenarij: u jednom numeričkom stupcu potkrala se nenumerička vrijednost (npr. niz znakova NULL zbog nedostajućih vrijednosti iz baze). Ovo može biti samo jedna vrijednost od više milijuna redaka, no to je dovoljno da R klasificira stupac kao “znakovni”. Budući da R automatski faktorizira znakovne stupce, u konačnom podatkovnom okviru taj numerički stupac postaje kategorijski (iako su nazivi kategorija zapravo brojevi). Nepažljivi analitičar (ili automatska skripta) ne uočava da se radi o faktoru već provodi konverziju navedenog stupca u numerički tip - i dobija potpuno semantički besmisleni niz “prekodiranih” cijelih brojeva koji, ako nisu pravovremeno uočeni, mogu biti korišteni kao ulazni podaci za daljnje analize. Zadatak 4.13 - važnost parametra stringsAsFactors = F # uz pomoć funkcije `read.csv` učitajte podatke iz datoteke `mjestoNULL.csv` # u varijablu `mjesto4` # nemojte koristiti parametar `stringsAsFactors` niti `na.strings` # ispišite sadržaj okvira `mjesto4` na zaslon # ispisite stupac `prosjPlaca` # primjenite funkciju `as.numeric` na stupac `prosjPlaca` i komentirajte rezultat # primjenite kombinaciju funkcija `as.character` i `as.numeric` na stupac `prosjPlaca` # i komentirajte rezultat # učitajte podatke iz datoteka `mjesto.csv` i `mjestoAlt.csv` # podatke spremite u okvire `mjesto2` i `mjesto3` mjesto4 &lt;- read.csv(&quot;mjestoNULL.csv&quot;) # ispišite sadržaj okvira `mjesto4` na zaslon mjesto4 ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359.00 790017 18 ## 2 51000 Rijeka NULL 128384 15 ## 3 21000 Split 5170.00 167121 10 ## 4 31000 Osijek 4892.00 84104 13 ## 5 20000 Dubrovnik 5348.00 28434 10 # ispisite stupac `prosjPlacaKn` mjesto4$prosjPlacaKn cat(&quot;----------------------\\n&quot;) # primjenite funkciju `as.numeric` na stupac `prosjPlacaKn` i komentirajte rezultat as.numeric(mjesto4$prosjPlacaKn) cat(&quot;----------------------\\n&quot;) # primjenite kombinaciju funkcija `as.character` i `as.numeric` na stupac `prosjPlacaKn` # i komentirajte rezultat # pazite na redoslijed poziva funkcija! as.numeric(as.character(mjesto4$prosjPlacaKn)) ## [1] 6359.00 NULL 5170.00 4892.00 5348.00 ## Levels: 4892.00 5170.00 5348.00 6359.00 NULL ## ---------------------- ## [1] 4 5 2 1 3 ## ---------------------- ## [1] 6359 NA 5170 4892 5348 Ponovimo - kako izbjeći ovaj scenarij? Procedura je vrlo jednostavna: kod korištenja funkcija read.csv ili read.table uvijek koristiti parametar stringsAsFactors = FALSE pažljivo pregledati tipove podataka stupaca učitanog okvira provesti odgovarajuće konverzije stupaca provjeriti dobivene rezultate Ako se pridržavamo ovih koraka gotovo nikada nećemo doći u situaciju da nam faktori prave probleme. Postoje i alternativne procedure (npr. eksplicitno navođenje tipova stupaca kod čitanja iz datoteke uz pomoć parametara colClasses, ili korištenje sintagme as.numeric(as.character()) za pretvaranje stupaca u numerički tip koja će provesti ispravnu konverziju neovisno o tome radi li se o znakovnom stupcu ili “prikrivenom” faktoru), no gore navedeni koraci bi u većini slučajeva trebali biti potpuno dovoljni. Najvažnija stvar za zapamtiti jest ključna uloga parametra stringsAsFactors = FALSE (koja se u literaturi zna navoditi kao obavezni parametar, bez dodatnih objašnjenja). Zadaci za vježbu U mapi zajedno sa ovom bilježnicom pronađite datoteku mjestoNOHEADER.csv koja predstavlja datoteku istovjetnu datoteci mjesto.csv osim sljedećih značajki: nedostaju imena stupaca korišten je razmak kao razdvojnik Pokušajte uz pomoć dokumentacije učitati podatke iz ove datoteke u varijablu mjestoNH koja će biti istovjetna varijabli mjesto korištenoj u lekciji. U mapi zajedno sa ovom bilježnicom pronađite datoteku racun.csv i učitajte ju u varijablu racun. Pripazite da nizovi znakova nisu automatski pretvoreni u faktore. Ispišite na zaslon: broj redaka ove tablice broj stupaca tablice imena stupaca tablice Za tablicu racun napravite sljedeće: faktorizirajte stupac katArtikl ispišite šifru, naziv i cijenu svih artikala kategorije “slatkisi i grickalice” jeftinijih od 12 Kn ispišite koliko proizvoda koje kategorije se nalazi u računu dodajte stupac ukupno koji će sadržavati ukupnu cijenu pojedine stavke uračunavajući i cijenu i količinu izračunajte ukupni iznos računa Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],
["kontrola.html", "5 Kontrola toka i objekti 5.1 Naredbe kontrole toka 5.2 Objektni modeli u jeziku R Zadaci za vježbu", " 5 Kontrola toka i objekti 5.1 Naredbe kontrole toka Pod naredbama kontrole toka smatramo uglavnom konstrukte za uvjetno izvođenje naredbi i/ili tzv. “programske petlje” gdje se segment programa kontinuirano izvodi sve do (opcionalnog) ispunjavana određenih uvjeta koji će rezultirati “izlaskom” iz petlje i nastavljanjem programa. 5.1.1 Uvjetno izvođenje naredbi Uvjetno izvođenje naredbi već smo upoznali. Radi se o konstruktu if (uvjet) { blok } else { blok } pri čemu se vitičaste zagrade mogu izbaciti ako imamo samo jednu uvjetnu naredbu. Ovdje je možda zgodno napomenuti kako izbjeći jednu relativno čestu početničku grešku kod pisanja if naredbe. Pokušajte ju samostalno uočiti i ispraviti u sljedećem primjeru. Zadatak 5.1 - naredba if # izvršite sljedeću naredbu uvjetnog izvođenja if (2 &gt; 1) print(&quot;Uspjeh!&quot;) # pronađite grešku u sljedećoj `if-else` naredbi i ispravite ju if (1 &gt; 2) print(&quot;Uspjeh!&quot;) else print(&quot;Neuspjeh!&quot;) # izvršite sljedeću naredbu uvjetnog izvođenja if (2 &gt; 1) print(&quot;Uspjeh!&quot;) # pronađite grešku u sljedećoj `if-else` naredbi i ispravite ju if (1 &gt; 2) { print(&quot;Uspjeh!&quot;) } else print(&quot;Neuspjeh!&quot;) ## [1] &quot;Uspjeh!&quot; ## [1] &quot;Neuspjeh!&quot; Greška se javlja zbog toga što je R interpreterski jezik koji se u pravilu izvršava redak po redak, osim u slučajevima kada smo R-u proslijedili “nedovršenu” naredbu pri čemu će on čekati na “ostatak” prije no što krene sa izvršavanjem. U prethodnom primjeru druga naredba if je zapravo završena u prvom retku, tako da se R “iznenadi” kada idući redak počinje sa else. Kako bi spriječili ovaj scenarij, dovoljno je na nekim način objasniti R-u da naredba još nije dovršena, što je najlakše izvesti otvaranjem bloka u prvom retku i zatvaranjem u retku sa else. Čitateljima koji programiraju u jezicima C ili Java biti će poznat pojam tzv. “ternarnog operatora” koji zapravo predstavlja kompaktnu verziju if-else bloka: x = (a &lt; b) ? c : d # nije primjer iz jezika R! Ulogu ovog operatora u R-u obavlja funkcija ifelse. Zadatak 5.2 - funkcija ifelse a &lt;- 1:3 b &lt;- c(0, 2, 4) # kako izgleda vektor `x` nakon izvršavanja sljedeće naredbe? # razmislite o odgovoru a potom provjerite ispravnost rješenja x &lt;- ifelse(a &lt; b, 2, 5) x &lt;- ifelse(a &lt; b, 2, 5) x ## [1] 2 2 2 2 Uočite da je funkcija ifelse (očekivano) vektorizirana, zbog čega je posebno pogodna za stvaranje novih stupaca podatkovnih okvira koji su izvedeni iz određenih uvjeta vezanih uz postojeće stupce. 5.1.2 Programske petlje U programskom jeziku R imamo tri tipa petlji: repeat - beskonačna petlja while - petlja s provjerom uvjeta na početku for - iteratorska petlja (“petlja s poznatim brojem ponavljanja”) 5.1.3 Petlja repeat Petlja repeat je najjednostavnija petlja. Ona ima sljedeću sintaksu: repeat {blok} Ovdje se radi o “beskonačnoj” petlji gdje se nakon završetka bloka on ponovo izvršava i tako unedogled. Jedini način izlaska iz ovakve petlje jest korištenje naredbe break. Pored ove naredbe imamo i naredbu next koja će preskočiti ostatak bloka, ali neće izaći iz petlje već će nastaviti izvršavati blok. Pogledajmo kako radi ova petlja u sljedećoj vježbi. Zadatak 5.3 - Petlja repeat # prije izvršavanja sljedećeg bloka odgovorite na pitanja: # - hoće li se petlja izvršavati beskonačno? # - što će se ispisati na zaslonu? i &lt;- 1 repeat { i &lt;- i + 1 if (i %% 2 == 0) next print(i) if (i &gt; 10) break } ## [1] 3 ## [1] 5 ## [1] 7 ## [1] 9 ## [1] 11 Često unaprijed znamo uvjet izlaska iz petlje te bismo ga htjeli staviti na jasno vidljivo mjesto tako da nije “skriven” u tijelu petlje. Za to nam pomaže tzv. while petlja. 5.1.4 Petlja while Petlja while predstavlja “najčišći” oblik programske petlje čija sintaksa doslovno glasi “dok je uvjet ispunjen, ponavljaj navedeni kod”: while (uvjet) {blok} Zadatak 5.4 - Petlja while # dodajte uvjet petlje tako da se ona izvrši # točno 7 puta i &lt;- 1 while() { print(i) i &lt;- i+1 } # dodajte uvjet petlje tako da se ona izvrši # točno 7 puta i &lt;- 1 while(i &lt;= 7) { print(i) i &lt;- i+1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 Kod ove petlje moramo paziti da se u određenoj iteraciji moraju stvoriti uvjeti za izlaz, inače ona također postaje “beskonačna” petlja. Usprkos tome što imamo jasno definiran način izlaska iz petlje, mi i u ovoj petlji možemo slobodno koristiti ključne riječi next i break, koje imaju istu funkciju kao i kod petlje repeat. 5.1.5 Petlja for Petlja for ili “iteratorska petlja” služi za lako “šetanje” po nekoj programskoj strukturi (najčešće vektoru), uzimajući element po element i nešto radeći s njim. Ona koristi ključnu riječ for, ime nove (iteratorske) varijable, ključnu riječ in te vektor čije vrijednosti se uzimaju jedna po jedna i koriste unutar petlje (uočite da navedeni in nije isto što i operator %in% koji provjerava da li se neki element nalazi u nekom skupu!). Sintaksa ove petlje je sljedeća: for (i in v) {radi nešto sa i} Uočimo da ovdje varijabla i nije “brojač” - u svakoj iteraciji petlje ona postaje vrijednost elementa do kojeg smo došli. Ukoliko baš želimo iterirati po indeksima, a ne po samim elementima, onda možemo koristiti konstrukt for (i in 1:length(a)). Treća varijanta jest iteriranje po imenima (ako smo definirali imena elemenata vektora) - for (i in names(a). Zadatak 5.5 - Petlja for a &lt;- seq(-10, 10, 4) # ispišite elemente vektora `a` jedan po jedan # uz pomoć petlje `for` # pristupajte elementima direktno # ponovite isto ali iterirajte po indeksima a &lt;- seq(-10, 10, 4) # ispišite elemente vektora `a` jedan po jedan # uz pomoć petlje `for` # pristupajte elementima direktno for (i in a) print(i) # ponovite isto ali iterirajte po indeksima for (i in 1:length(a)) print(a[i]) ## [1] -10 ## [1] -6 ## [1] -2 ## [1] 2 ## [1] 6 ## [1] 10 ## [1] -10 ## [1] -6 ## [1] -2 ## [1] 2 ## [1] 6 ## [1] 10 Uočite da je drugi način bolji ako želite mijenjati elemente vektora ili imati informaciju na kojem mjestu unutar originalnog vektora se trenutno nalazite. *** Sad kad smo naučili sintaksu petlji važno je naglasiti jednu činjenicu - u programskom jeziku R u pravilu se ne preporučuje korištenje programskih petlji . Iako ovo inicijalno možda djeluje neočekivano i pomalo šokantno, razlog je jednostavan - R je jezik dizajniran upravo da radi po principu “sve odjednom”. Već smo vidjeli da principu vektoriziranosti i recikliranja učinkovito obavljaju poslove koji bi u drugim programskim jezicima zahtijevali petlju, a u poglavljima koje slijede vidjet ćemo da R nudi i mnoge druge konstrukte koji izbjegavaju eksplicitno ponavljanje koda uz uvjet nauštrb deklarativne sintakse koja to obavlja automatski. Na primjer, sljedeći primjer je sintaksno potpuno ispravan: # primjer nepotrebnog korištenja petlje a &lt;- 1:5 b &lt;- 6:10 c &lt;- numeric() for (i in 1:length(a)) c[i] &lt;- a[i] + b[i] ali vjerojatno radi sporije i puno je nečitljiviji od: # R-ovska sintaksa a &lt;- 1:5 b &lt;- 6:10 c &lt;- a + b Sve navedeno naravno ne znači da petlje u R-u ne smijemo koristiti, samo da bi njihovo korištenje trebalo biti popraćeno dodatnim razmatranjem da li je na tom mjestu petlja zaista potrebna te da li postoji alternativna sintaksa koji isti posao obavlja deklarativno (i potencijalno brže, budući da su mnoge rutine R-a implementirane u jeziku C). Rano prihvaćanje “R-ovskog” načina razmišljanja rezultirati će dugoročnim benefitom koji će se očitovati kompaktnijim, čišćim i često učinkovitijim programskim kodom. 5.2 Objektni modeli u jeziku R Kako bismo objasnili što su zapravo generičke funkcije, moramo se vratiti na priču o programskim paradigmama i činjenici da je R dizajniran kao objektno orijentirani jezik, zajedno sa mehanizmima koje objektno orijentirana paradigma nalaže - enkapsulacija (združivanje različitih varijabli u zajedničku cjelinu), polimorfizam (korištenje iste funkcije nad različitim objektima rezultira različitim operacijama ovisno o prirodi objekta) i nasljeđivanje (izvođenje novih objekata iz postojećih na način da ih proširujemo dodatnim elementima). R je svoj inicijalni način modeliranja objekata preuzeo iz jezika S te su stoga takvi objekti poznati kao “S3 objekti” (prema inačici jezika S iz koje su originalno preuzeti). Ovaj način, kojeg ćemo upoznati u nastavku, zapravo je vrlo nekonvencionalan i jednostavan no kao takav i prilično podoban za korištenje R-a kao primarno domenski orijentiranog jezika. Uplivom sve većeg broja programera u R zajednicu rastao je i pritisak da se u R uvede podrška za objekte koja će biti sličnija načinu kako njima upravljaju drugi programski jezici, a koja bi povećala robustnost kod dizajna i upravljanja objektima. Sve je to dovelo do toga da danas formalno imamo čak četiri tipa objekata u programskom jeziku R: osnovni objekti (base classes) - osnovni, “bazični” elementi jezika R (funkcije, vektori, podatkovni okviri) S3 objekti - princip dizajna objekata preuzet iz jezika S (inačica 3) S4 objekti - formalniji i rigorozniji način stvaranja objekata koji se približava standardnim objektno-orijentiranim mehanizmima iz drugih jezika RC objekti (reference classes) - najnoviji način stvaranja objekata (uveden u inačici R 2.12) koji u potpunosti replicira “klasične” objektno-orijentirane principe utemeljene na razmjeni poruka Postojanje tri različita modela definiranja objekata (možemo zanemariti osnovni budući da njega formalno ne možemo “proširivati” novim objektima) može djelovati demotivirajuće - da li je potrebeno naučiti sva tri modela? Kako ih razlikovati? Koji odabrati? No usprkos činjenici da se priča o objektnoj prirodi jezika R tijekom njegova razvoja (nepotrebno) zakomplicirala, dobra vijest je ta da je za većinu potreba sasvim dovoljno naučiti kako radi S3 model, koji je ujedno i najjednostavniji. Veliki broj popularnih R paketa koristi isključivo S3 klase i moguće je raditi dugo vremena u jeziku R bez potrebe za učenjem S4 ili RC modela. Zbog ove činjenice ćemo u nastavku se usredotočiti isključivo na S3 klase (čitatelji koji žele više informacija o ostalim modelima mogu pogledati vrlo dobru knjigu “Advanced R”, autora Hadley-a Wickhama, koja se između ostalog detaljnije bavi objektnim modelima u R-u i njihovom usporedbom). 5.2.1 Pregled objektnog modela S3 Kao što je već rečeno, S3 objekti zapravo su preneseni iz programskog jezika S i predstavljaju relativno primitivno poimanje koncepta “objekta”, barem što se tiče očekivanja glede standardnih metoda stvaranja objekata i pripadajućih metoda. S3 objekt je zapravo obična lista kojoj smo definirali class atribut. # stvaramo novi objekt klase `osoba` pero &lt;- list(oib = &quot;12345678&quot;, prezime = &quot;Peric&quot;, tezina = 78) class(pero) &lt;- &quot;Osoba&quot; I to je to! Uočite da nemamo formalno definiranog “predloška” klase kojeg onda instanciramo u objekt kao što je ustaljena praksa u drugim programskim jezicima. Kod S3 objekata jednostavno stvaramo listu i onda deklariramo da je ta lista objekt određene klase, iako je struktura te klase zapravo samo implicirana izgledom objekta (i ne mora uopće odgovarati strukturi nekog drugog objekta koji se deklarirao da pripada istoj klasi). Naravno, ovako ležeran način konstrukcije objekata ipak nije preporučljiv te se zbog toga preporučuje da klase ne deklariramo “ručno” već da to radimo uz pomoć posebne konstruktorske funkcije čiji će parametri zapravo definirati izgled objekta (ovo ćemo naučiti u lekciji o stvaranju vlastitih funkcija) Što je s nasljeđivanjem, gdje klasa-dijete nasljeđuje tj. proširuje svojstva klase-roditelja? R omogućuje nasljeđivanje, ali također na vrlo neformalan i relativno trivijalan način. Umjesto da navedemo samo jedan “naziv” klase uz pomoć atributa class, mi stvorimo znakovni vektor gdje će prvi element biti naziv klase, a ostali elementi će biti klase roditelji, poredani prema “važnosti”. Na primjer, ako smo stvorili novi objekt mate klase Zaposlenik nad kojim bi htjeli koristiti iste implementacije određenih generičkih metoda razvijenih za potrebe objekata klase Osoba, onda je dovoljno izvesti sljedeće: mate &lt;- list(oib = &quot;12345678&quot;, prezime = &quot;Peric&quot;, tezina = 78, godZaposlenja = 2001) class(mate) &lt;- c(&quot;Zaposlenik&quot;, &quot;Osoba&quot;) Primijetimo da sav posao oko nasljeđivanja atributa moramo obaviti “ručno”, tj. moramo se sami pobrinuti da mate ima atribute klase Osoba koje će generička funkcija koju pozivamo koristiti. 5.2.2 Generičke funkcije Gledajući gore definirani način dizajna objekta opravdano je postaviti i dodatno pitanje - a gdje su metode? Kao što znamo, standardni objektno-orijentirani principi pretpostavljaju enkapsulaciju atributa ali i metoda u okvir objekta. Upravo tu leži osnovna razlika između S3 objekta i “standardnih” objekata iz drugih programskih jezika - kod S3 objekata metode se definiraju izvan objekta u obliku tzv. generičkih funkcija. Zašto je tome tako? Ideja jest sljedeća - u radu sa objektima korisnik (programer, analitičar) često poziva iste funkcije (npr. “ispis”, “crtanje”, “sažeti opis”) nad objektima različitog tipa. Funkcija istog imena ali različite implementacije ovisno o objektu nad kojim radi zove se generička funkcija. Tako recimo funkcija print uvijek rezultira nekakvim ispisom, ali kako će ispis izgledati zapravo ovisi o objektu kojeg ispisujemo. Ovaj način dizajna objekata može djelovati iznimno nekonvencionalno, no činjenica jest da on pozive funkcija čini puno intuitivnijim, pogotovo korisnicima koji nemaju veliko iskustvo sa programiranjem. Konkretno, usporedimo naredbu: pokreni(auto, brzina = 20) s naredbom: auto.pokreni(brzina = 20) Čitajući prvu naredbu auto doživljavamo kao “objekt” (u smislu službe riječi u rečenicu), tj. nešto radimo “nad” tim objektom. Druga naredba auto postavlja kao subjekt, što je uobičajena praksa u objektno-orijentiranim jezicima ali nije u skladu sa općenitim poimanjem obavljanja radnji nad nekim objektima. U radu s programskim jezikom R često radimo “slične” poslove nad različitim objektima - ispisujemo njihov sadržaj, crtamo ih na grafu, tražimo neke sažete detalje o njima i sl. Upravo zbog toga, a i činjenice da u R-u često radimo interaktivno, R je dizajniran na način da razmišljamo što želimo učiniti umjesto da se pitamo gdje se nalazi funkcija koju želimo pozvati. Ako želimo ispisati neki objekt, logično je da ga samo proslijedimo funkciji print, ako ga želimo nacrtati funkciji plot, a ako želimo sažetak funkciji summary. Kako pojedina funkcija “zna” što učinit sa objektom? Odgovor je jednostavan - generička funkcija je samo “sučelje” prema “pravoj” funkciji koju pozivamo, a logika kako pronaći pravu funkciju je vrlo trivijalna - ako je ime generičke funkcije genFun a naziv klase objekta koju joj prosljeđujemo nazKlase, funkcija koja se zapravo poziva jest genFun.nazKlase. Ako takve funkcije nema, poziva se funkcija genFun.default. U ovo se lako možemo uvjeriti samostalno u sklopu sljedeće vježbe. Zadatak 5.6 - Generičke funkcije # ispišite funkciju `summary` (samo naziv funkcije!) # ispišite funkciju koja se zapravo poziva kad pozovete # funkciju `summary` nad objektom klase `factor` # ispišite funkciju `summary` summary # ispišite funkciju koja se zapravo poziva kad pozovete # funkciju `summary` nad objektom klase `factor` summary.factor ## standardGeneric for &quot;summary&quot; defined from package &quot;base&quot; ## ## function (object, ...) ## standardGeneric(&quot;summary&quot;) ## &lt;environment: 0x00000000147eb6b0&gt; ## Methods may be defined for arguments: object ## Use showMethods(&quot;summary&quot;) for currently available ones. ## function (object, maxsum = 100L, ...) ## { ## nas &lt;- is.na(object) ## ll &lt;- levels(object) ## if (ana &lt;- any(nas)) ## maxsum &lt;- maxsum - 1L ## tbl &lt;- table(object) ## tt &lt;- c(tbl) ## names(tt) &lt;- dimnames(tbl)[[1L]] ## if (length(ll) &gt; maxsum) { ## drop &lt;- maxsum:length(ll) ## o &lt;- sort.list(tt, decreasing = TRUE) ## tt &lt;- c(tt[o[-drop]], `(Other)` = sum(tt[o[drop]])) ## } ## if (ana) ## c(tt, `NA&#39;s` = sum(nas)) ## else tt ## } ## &lt;bytecode: 0x0000000020219578&gt; ## &lt;environment: namespace:base&gt; Razumijevanjem principa rada generičkih funkcija upotpunili smo sliku o S3 objektima. Najvažnija stvar koju moramo usvojiti jest da kod ovog modela funkcije nisu dio samog objekta, već se definiraju zasebno, a poveznica između objekta i “njegove” metode jest samo u nazivu funkcije pomoću kojeg će R “povezati” generičku funkciju i taj objekt. Iako je ovaj princip primitivan i podložan greškama u rukama nepažljivog programera, on je neumitno jednostavan za uporabu i vrlo učinkovit. Konačno, uočimo da ovaj pristup nije u potpunosti svojstven isključivo jeziku R - slične principe nalazimo i u drugim programskim jezicima (npr. Python povezuje print funkciju i objekt preko posebne metode objekta __str__). R je samo specifičan po tome što taj princip koristi otvoreno i gotovo isključivo. Objekte i generičke funkcije ćemo ponovo posjetiti kada naučimo stvarati vlastite funkcije, što će nam omogućiti da stvorimo kako konstruktore naših objekata, tako i njihove generičke funkcije. 5.2.3 Zaključci o S3 objektima Ukratko, zaključci o S3 objektima mogu biti sljedeći: S3 objekti funkcioniraju na jednostavan, neformalan način - to su jednostavno liste sa postavljenom proizvoljnom vrijednosti class atributa puno toga ostavljeno je na odgovornosti programera metode S3 objekata ne enakpsuliraju se unutar objekata, već se dizajniraju “izvan” objekata u obliku generičkih funkcija S3 objekti jednostavni su za uporabu ako su i objektni modeli koje dizajniramo nisu jednostavni, ali nisu pogodni za kompleksnije objektne modele zbog teškog održavanja modela i velike mogućnosti pogrešaka Zadaci za vježbu Stvorite podatkovni okvir mjesto uz pomoć sljedeće naredbe: mjesto &lt;- data.frame( pbr = c(10000, 51000, 21000, 31000, 2000), nazivMjesta = c(&quot;Zagreb&quot;, &quot;Rijeka&quot;, &quot;Split&quot;, &quot;Osijek&quot;, &quot;Dubrovnik&quot;), prirez = c(18, 15, 10, 13, 10)) Dodajte ovom okviru stupac prirezOpis koji će biti ordinalna faktorska varijabla sa razinama &quot;mali&quot;, &quot;srednji&quot; i &quot;visok&quot; ovisno o tome da li je postotak prireza strogo manji od 12, između 12 i 15 ili strogo veći od 15. Koristite se naredbom ifelse. Zamijenite petlje u sljedećem bloku ekvivalentnim vektoriziranim operacijama (za drugu petlju proučite dokumentaciju funkcije sum). a &lt;- numeric() i &lt;- 1 while (i &lt;= 100) { a &lt;- c(a, i) i &lt;- i + 1 } suma &lt;- 0 for (i in a) { if (i %% 2 == 0) suma &lt;- suma + i*i } print(suma) Stvorite objekt klase Kvadar sa atributima visina, sirina i dubina jednakim 10, 20 i 30. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],
["paketi.html", "6 Paketi, ugrađene funkcije i okoline 6.1 Rad s paketima 6.2 Ugrađene funkcije 6.3 Okoline Zadaci za vježbu", " 6 Paketi, ugrađene funkcije i okoline 6.1 Rad s paketima Standardna R distribucija dolazi sa dvije kolekcije paketa (nazvanih r-base i r-recommended) koje sadrže svojevrsnu “jezgru” jezika R - skup elemenata dostatnih za provođenje standardnih tipova podatkovnih analiza uz pomoć programskog jezika R. Uz to, CRAN (Comprehensive R Archive Network) predstavlja bogati repozitorij dodatnih paketa za najrazličitije primjene, od “popravljanja” osnovnih elemenata jezika R do strogo specijaliziranih paketa za posebne tipove analiza. Kao što je uobičajena praksa u drugim programskim jezicima, R koristi sustav “paketa” ili “biblioteka” (engl. package ili library) kako bi logički organizirao već “isprogramirane” kolekcije podataka, skupova i prevedenog programskog koda. Kod podizanja R okoline automatski se učitavaju određeni paketi u radnu memoriju čime njihovi elementi postaju dostupni za korištenje. Popis učitanih paketa možemo dobiti korištenjem funkcije search. Zadatak 6.1 - staza pretrage # pozovite funkciju `search` (bez parametara) i pogledajte koji paketi su učitani u okolinu # pozovite funkciju `search` (bez parametara) i pogledajte koji paketi su učitani u okolinu search() ## [1] &quot;.GlobalEnv&quot; &quot;package:corrplot&quot; &quot;package:broom&quot; ## [4] &quot;package:car&quot; &quot;package:carData&quot; &quot;package:Hmisc&quot; ## [7] &quot;package:Formula&quot; &quot;package:survival&quot; &quot;package:lattice&quot; ## [10] &quot;package:sn&quot; &quot;package:stats4&quot; &quot;package:gridExtra&quot; ## [13] &quot;package:RSQLite&quot; &quot;package:hflights&quot; &quot;package:lubridate&quot; ## [16] &quot;package:GGally&quot; &quot;package:forcats&quot; &quot;package:stringr&quot; ## [19] &quot;package:dplyr&quot; &quot;package:purrr&quot; &quot;package:readr&quot; ## [22] &quot;package:tidyr&quot; &quot;package:tibble&quot; &quot;package:ggplot2&quot; ## [25] &quot;package:tidyverse&quot; &quot;package:MASS&quot; &quot;package:stats&quot; ## [28] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; ## [31] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; ## [34] &quot;package:base&quot; Vidimo da većina paketa ima svoju stavku oblika &quot;package:ime_paketa&quot;. Raspored paketa predstavlja i njihov “prioritet” glede pretrage imenskog područja, o čemu će više riječi biti kasnije. Ukoliko želimo učitati novi paket u našu okolinu, to možemo izvesti uz pomoć funkcije library kojoj dajemo ime paketa (bez navodnika). Zadatak 6.2 - učitavanje paketa u radnu okolinu # učitajte paket `dplyr` u R okolinu # učitajte paket `dplyr` u R okolinu library(dplyr) Naredba iz prethodnog primjera može imati dva ishoda: ukoliko paket postoji na lokalnom računalu (u mapi predodređenoj za dodatne pakete), on će biti učitan u radnu okolinu. Učitavanje paketa može biti popraćeno porukama o objektima koji su nakon učitavanja “maskirani”. To konkretno znači da je novi paket privremeno uskratio dostupnost pojedinim elementima iz ranije učitanih paketa iz razloga što im se podudaraju imena. Ovo često ne predstavlja nikakav problem, ali ukoliko korisnik ima potrebu za pristupom maskiranim elementima morati će koristiti njihovo “puno” ime tj. morati će navesti i ime paketa gdje se nalaze. Na primjer, ako je funkcija filter iz paketa stats maskirana nakon učitavanja novog paketa, ona je i dalje dostupna preko punog imena stats::filter ali ne direktno preko filter, budući da će to pozivati funkciju iz najnovije učitanog paketa. Više detalja o tome kako R razrješava nazive varijabli i funkcija biti će dano u nastavku ove lekcije. Ukoliko na lokalnom računalu nemamo navedeni paket dobivamo poruku o grešci da taj paket ne postoji. U tom slučaju potrebno je prvo dohvatiti paket iz CRAN repozitorija uz pomoć funkcije install.packages kojoj dajemo naziv jednog ili više paketa (s navodnicima!) kao parametre. Navedena funkcija pretpostavlja da R okolina ima definiran CRAN mirror tj. konkretnu adresu CRAN repozitorija odakle će se paket dohvatiti. Veliki broj država ima svoju “kopiju” CRAN repozitorija, no nažalost Republika Hrvatska iz nejasnih razloga više nema svoj CRAN repozitorij te u trenutku pisanja ove bilježnice nema pokazatelja da će se isti uspostaviti. Ako radimo u sučelju RStudio, CRAN repozitorij smo vrlo vjerojatno postavili kod prvog pokretanja, (tj. odabrali smo opciju Global koja naše zahtjeve za instaliranjem paketa automatski prosljeđuje najbližem CRAN repozitoriju) no ako to nismo obavili ili radimo u nekom drugom razvojnom sučelju onda uz pomoć dokumentacije moramo potražiti način postavljanja CRAN repozitorija ako želimo učitavati dodatne pakete. Zadatak 6.3 - instalacija paketa sa CRAN repozitorija # instalirajte paket `dplyr` sa CRAN repozitorija # (ovo možete učiniti čak i ako već imate navedeni paket) # učitajte ponovo paket u radnu okolinu # ispišite stazu pretrage # instalirajte paket `dplyr` sa CRAN repozitorija # (nije nužno ako već imate navedeni paket, ali obratite pažnju na sintaksu) install.packages(&quot;dplyr&quot;) # učitajte ponovo paket u radnu okolinu library(dplyr) # ispišite stazu pretrage search() ## [1] &quot;.GlobalEnv&quot; &quot;package:corrplot&quot; &quot;package:broom&quot; ## [4] &quot;package:car&quot; &quot;package:carData&quot; &quot;package:Hmisc&quot; ## [7] &quot;package:Formula&quot; &quot;package:survival&quot; &quot;package:lattice&quot; ## [10] &quot;package:sn&quot; &quot;package:stats4&quot; &quot;package:gridExtra&quot; ## [13] &quot;package:RSQLite&quot; &quot;package:hflights&quot; &quot;package:lubridate&quot; ## [16] &quot;package:GGally&quot; &quot;package:forcats&quot; &quot;package:stringr&quot; ## [19] &quot;package:dplyr&quot; &quot;package:purrr&quot; &quot;package:readr&quot; ## [22] &quot;package:tidyr&quot; &quot;package:tibble&quot; &quot;package:ggplot2&quot; ## [25] &quot;package:tidyverse&quot; &quot;package:MASS&quot; &quot;package:stats&quot; ## [28] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; ## [31] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; ## [34] &quot;package:base&quot; Napomena: u pravilu pakete instaliramo samo jednom i to preko konzole tako da nikad nema potrebe naredbe za instalaciju paketa ugrađivati u R Markdown dokumente; također, zbog lakše organizacije izvještaja, učitavanje svih potrebnih paketa se po konvenciji obavlja na početku dokumenta, u isječku koda nazvanom setup. Uočimo da će instalacija i učitavanje paketa automatski sa sobom povući i učitavanje svih paketa koji su preduvjeti za korištenje traženog paketa, što uvelike olakšava rad korisniku koji se ne mora brinuti o tome što “dodatno” treba instalirati kako bi mogao koristiti elemente paketa. Ako želimo saznati više informacija o nekom paketu, to također možemo izvesti uz pomoć funkcije library uz parametar help postavljen na ime paketa. library(help = dplyr) # preporuka: isprobati direktno u konzoli Još jedan prilično popularan način dokumentiranja paketa je uz pomoć tzv. “vinjeta” (engl. vignettes). Vinjete su zapravo “mini-tutorial” nekog paketa u HTML obliku koji služi za predstavljanje funkcionalnosti paketa na pristupačan, čitljiv način uz pomoć detaljnih objašnjenja i pripadajućeg programskog koda. Možemo pogledati koje vinjete su instalirane na sustav pozivom funkcije browseVignettes() bez parametara (ili opcionalno dodati kao parametar imena paketa ako nas zanimaju samo njegove vinjete). Ako paket ima samo jednu vinjetu (npr. paket stringr). Možemo također odmah otvoriti vinjetu uz pomoć funkcije vignette(ime_paketa). vignette(&quot;stringr&quot;) # preporuka: isprobati direktno u konzoli 6.2 Ugrađene funkcije U prethodnim poglavljima već smo upoznali neke od gotovih funkcija koje dobijamo zajedno sa našom R distribucijom. To su npr. numeričke funkcije (log, abs, sqrt, round i sl.), funkcije za stvaranje vektora (rep, seq i sl.), funkcije za rad s paketima (install.packages, library i sl.) i tako dalje. U R-u se rijetko govori o “ugrađenim” funkcijama budući da - kao što je već prikazano - R okolina automatski učitava neke često korištene pakete čiji su elementi odmah dostupni za korištenje, bez nužnog navođenja imena paketa u kojem se nalaze. Npr. paket stats sadrži bogati skup funkcija vezanih uz statističke obrade. Jedna od tih funkcija je i rnorm koja vraća numerički vektor željene duljine čiji su elementi nasumično odabrani iz normalne distribucije sa aritmetičkom sredinom 0 i standardnom devijacijom 1 (ove vrijednosti možemo i promijeniti uz pomoć parametara mean i sd). Ukoliko želimo, ovu funkciju možemo pozvati uz pomoć sintakse ime_paketa::ime_funkcije(parametri). Zadatak 6.4 - poziv funkcije iz definiranog paketa # stvorite vektor x koji će imati 10 slučajnih elemenata # izvučenih iz standardne normalne distribucije # koristite puni naziv funkcije `rnorm` iz paketa `stats` # zaokružite elemente vektora x na dvije decimale # koristite puni naziv funkcije `round` iz paketa `base` # ispišite vektor x # stvorite vektor x koji će imati 10 slučajnih elemenata # izvučenih iz standardne normalne distribucije # koristite puni naziv funkcije `rnorm` iz paketa `stats` x &lt;- stats::rnorm(10) # zaokružite elemente vektora x na dvije decimale # koristite puni naziv funkcije `round` iz paketa `base` x &lt;- base::round(x, 2) # ispišite vektor x x ## [1] 0.04 0.11 1.43 0.98 -0.62 -0.73 -0.52 -1.75 0.88 1.37 Iako je ovo sintaksno korektan način pozivanja funkcije, R nam omogućuje da izuzmemo nazive paketa i jednostavno navedemo samo naziv funkcije. Zadatak 6.5 - poziv funkcije bez imena paketa # stvorite vektor y po istom principu kao i vektor x # obavite sve u jednom retku # koristite nazive funkcija bez naziva paketa # ispišite y # stvorite vektor y po istom principu kao i vektor x # obavite sve u jednom retku # koristite nazive funkcija bez naziva paketa y &lt;- round(rnorm(10), 2) # ispišite y y ## [1] -1.69 -0.63 0.02 0.71 -0.65 0.87 0.38 0.31 0.01 -0.04 Možemo se zapitati - kako R zna gdje se nalazi funkcija koju želimo pozvati, ako nismo eksplicitno učitali niti naveli paket koji sadrži tu funkciju? Točan razlog objasniti ćemo u idućem poglavlju koje se bavi okolinama i već viđenom “stazom pretrage”. Popisivanje svih dostupnih funkcija, pa čak i onih češće korištenih, bilo bi redundantno budući da se R jezik najbolje uči uz konkretnu primjenu, pri čemu nakon određenog vremena korištenja korisnik polako oformi “vlastiti” skup funkcija koje predstavljaju njegov uobičajeni “alat” za analize. U svakom slučaju, svakako se preporučuje odabir nekog od javno dostupnih R podsjetnika (reference card ili cheat sheet) koji će onda uvijek biti pri ruci za vrijeme R programiranja. Pojedini R podsjetnici dostupni su i na samom CRAN-u (dovoljno je upisati CRAN reference card u tražilicu i pregledati rezultate), no ovdje ćemo iskoristiti priliku i preporučiti izvrsne “šalabahtere” na stranicama sučelja RStudio dostupne na sljedećoj poveznici: https://www.rstudio.com/resources/cheatsheets/ (alternativno, upišite RStudio cheat sheets u tražilicu). Ovi podsjetnici sadržajno pokrivaju većinu korisnih stvari vezanih uz općenite elemente jezika R (Base R, Advanced R) ali i konkretne pakete koje ćemo kasnije upoznati (dplyr, ggplot2) te predstavljaju vrlo vrijedne resurse kako za učenje R-a, tako i za dugoročno korištenje. Za lakše praćenje lekcija koje slijede, preporučujemo ispis navedenih podsjetnika i upoznavanje sa elementima koje sadržavaju, budući da se predstavlja o dugoročno korisnom pomagalu za programiranje u jeziku R. Za kraj, spomenimo da nam R omogućuje brzo dohvaćanje pomoći o funkciji jednostavnim pozivom ?ime_funkcije ili help(ime_funkcije) te da možemo dobiti primjere korištenja funkcije kroz example(ime_funkcije). Ove pozive bismo trebali vrlo često koristiti čak i ako smatramo da smo dobro upoznati sa funkcijom koju pozivamo - lako je moguće da postoji neki dodatni parametar (ili srodna funkcija koje se također često navode u dokumentaciji) a koji će nam dodatno pomoći u obavljanju zadatka zbog kojeg funkciju i koristimo. 6.3 Okoline Kao što je već rečeno, rad u R-u svodi se na upravljanje različitim objektima. Kako bismo uopće mogli upravljati tim objektima, potrebni su nam mehanizmi uz pomoć kojih referenciramo dotične objekte. U R-u se to zove “povezivanje” (engl. binding). Kada stvorimo varijablu x numeričkog tipa i njoj pridružimo broj 5, mi smo zapravo stvorili (jednoelementni) numerički vektor i “povezali” taj podatak sa nizom znakova &quot;x&quot; kojeg potom možemo koristiti za daljnje referenciranje tog podatka (ili tih podataka). Stoga, kada želimo pristupiti nekoj varijabli, R mora pretražiti svoj interni “zapisnik” koje varijable trenutno postoje, kojeg su tipa te kako im pristupiti. Kako bi R pronašao varijablu, on koristi mehanizam zvan “leksičko uokviravanje” (engl. lexical scoping) koji se temelji na konceptu zvanom okoline (engl. environments). “Okolina” se često naziva “vrećom za nazive” (engl. bag of names). Ona nam pomaže da logički grupiramo nazive objekata koje koristimo i da pomognemo R-u naći naziv u drugim okolinama ako isti ne postoji u trenutnoj okolini. Ovo potonje je omogućeno na način da (gotovo) svaka okolina ima poveznicu na svoju okolinu-roditelja (engl. parent environment). Ovakav sustav poveznica na okoline-roditelje stvara svojevrsnu “hijerarhiju okolina” koja se često naziva i “staza pretrage” (engl. search path); R, tražeći zadano ime varijable, pretražuje okoline “uzlazno” sve dok ne pronađe prvu pojavu traženog naziva ili naleti na krajnju okolinu bez roditelja (tzv. prazna okolina - engl. empty environment). Ono što je interesantno jest činjenica da je i sama okolina objekt - možemo stvoriti referencu na nju, slati ju u funkcije i sl. “Osnovna” okolina u kojoj radimo i u kojoj stvaramo nove varijable je tzv. globalna okolina, ili .GlobalEnv (paziti na točku!). Ona je na dnu hijerarhije okolina. Možemo dohvatiti referencu na nju preko istoimene varijable, ili se poslužiti funkcijom globalenv(). Zadatak 6.6 - globalna okolina # stvorite varijablu e i u nju pohranite referencu na globalnu okolinu # ispišite varijablu e # stvorite varijablu x i u nju ubacite broj 5 # izvršite funkciju `ls` bez parametara # izvršite funkciju `ls` sa varijablom `e` kao parametrom # ispišite x # ispišite e$x (uočite sintaksu liste!) # stvorite varijablu e i u nju pohranite referencu na globalnu okolinu e &lt;- .GlobalEnv # ili e &lt;- globalenv() # ispišite varijablu e e # stvorite varijablu x i u nju ubacite broj 5 x &lt;- 5 # izvršite funkciju `ls` bez parametara #ls() # probati na konzoli! # izvršite funkciju `ls` sa varijablom `e` kao parametrom #ls(e) # probati na konzoli! # ispišite x x # ispišite e$x (uočite sintaksu liste!) e$x ## &lt;environment: R_GlobalEnv&gt; ## [1] 5 ## [1] 5 Iz zadnjeg primjera možemo vidjeti da okolina bez problema može čuvati i referencu na samu sebe obliku varijable e, tako da je ovo zapravo potpuno ispravna (iako nepotrebno komplicirana) sintaksa za ispis varijable x: e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$x Okoline su u izvjesnoj mjeri slične listama, koje su isto zapravo svojevrsni način “enkapsulacije” niza objekata u jedinstvenu strukturu. Najbitnije razlike između okoline i liste su: poredak elemenata u okolini je nebitan okolina (u pravilu) ima poveznicu na okolinu roditelja Pogledajmo tko je okolina-roditelj globalnoj okolini uz pomoć funkcije parent.env. Zadatak 6.7 - okoline roditelji # ispišite okolinu-roditelja globalne okoline i objasnite rezultat # ispišite okolinu-roditelja globalne okoline i objasnite rezultat parent.env(e) ## &lt;environment: package:corrplot&gt; ## attr(,&quot;name&quot;) ## [1] &quot;package:corrplot&quot; ## attr(,&quot;path&quot;) ## [1] &quot;C:/R/R-3.5.1/library/corrplot&quot; Pomalo neočekivano, roditelj globalne okoline jest zadnje učitani paket! Ovo zapravo nije neobično - globalna okolina ima “prioritet” kod referenciranja varijable, ali prioritetno odmah “ispod” nje su oni objekti i funkcije koje smo zadnje učitali u okolinu (što nam odgovara budući da je pretpostavka da je “najsvježije” učitani paket onaj kojeg namjeravamo odmah koristiti). Drugim riječima, učitavanjem paketa novi paket se uvijek “namjesti” između globalne okoline i paketa koji je prije njega bio zadnji učitan. Kada smo pozivali funkciju search, zapravo smo dobili hijerarhiju okolina koje predstavljaju učitane pakete. Ova hijerarhija okolina ujedno predstavlja i već spominjanu “stazu pretrage”. Uz pomoć funkcije parent.env možemo sami odrediti koju okolinu će neka okolina smatrati roditeljem. Na ovaj način možemo napraviti vlastitu hijerarhiju okolina. Nadalje varijable koje stvaramo ne moraju koristiti reference iz globalne okoline (što je zapravo i osnovna funkcija operatora &lt;-), mi ih možemo pohraniti u bilo koju okolinu koju želimo, no za to se moramo koristiti funkcijama assign i get ili kombinacijom operatora $ i &lt;-. # primjer - stvaramo malu hijerarhiju okolina i pohranjujemo # te ispisujemo varijablu koristeći jednu od njih e2 &lt;- new.env() e3 &lt;- new.env() # hijerarhija `e3` --&gt; `e2` --&gt; `e` (globalna) parent.env(e2) &lt;- e parent.env(e3) &lt;- e2 # stvaramo varijablu `x` u okolini `e2` assign(&quot;x&quot;, 5, e2) # ili e2$x &lt;- 5 # provjera postoji li varijabla `x` u okolini `e2` exists(&quot;x&quot;, e2) # ispis varijable `x` iz okoline e2 get(&quot;x&quot;, e2) #ili e2$x ## [1] TRUE ## [1] 5 Zašto bi koristili okoline u praksi? Okolina predstavlja zgodan način “omatanja” skupa varijabli koje onda zajedno možemo slati u neku funkciju - što je pogotovo zgodno ako dotične varijable referenciraju neke velike skupove podataka. Kao što ćemo vidjeti u sljedećoj lekciji, R ne podržava tzv. call-by-reference princip već kod slanja objekata u funkciju R koristi tzv. copy-on-modify mehanizam. Ovo znači da će funkcija koristiti referencu na originalni objekt poslan u nju kao parametar sve do naredbe koja taj objekt odluči mijenjati; u tom trenutku stvara se kopija tog objekta i tek onda se provode izmjene. Ovo može dovesti do značajnih usporavanja programa kod programera koji nisu upoznati s ovom činjenicom a koji npr. programiraju funkciju koja transformira podatkovni okvir. Ako funkciji umjesto reference na podatkovni okvir pošaljemo referencu na okolinu u koju je “zamotan” okvir, onda neće doći do kopiranja varijable jer je okolina jedini objekt za kojeg copy-on-modify ne vrijedi. Uočimo da je specijalni slučaj ove metode “slanje” globalne okoline u funkciju, što se zapravo svodi na korištenje “globalne varijable” - nečega što se u drugim programskim jezicima često izbjegava, ali u R-u nije pretjerano rijetka pojava upravo zbog činjenice da nas znatno usporavanje programa puno više smeta od potencijalnih problema koje globalne varijable sa sobom donose. Za kraj demonstrirajmo rad funkcije attach koju analitičari često koriste kako bi ubrzali postupak analize ali koja može uzrokovati probleme ako nismo pažljivi sa njenim korištenjem. Ova funkcija ubaciti će podatkovni okvir direktno u stazu pretrage kako bi nam omogućila “lakši” pristup varijablama, ni uz potencijalne nezgodne nuspojave. Pogledajmo ovo na primjeru. Zadatak 6.8 - funkcija attach mjesto &lt;- data.frame( pbr = c(10000, 51000, 21000, 31000, 2000), nazivMjesta = c(&quot;Zagreb&quot;, &quot;Rijeka&quot;, &quot;Split&quot;, &quot;Osijek&quot;, &quot;Dubrovnik&quot;), prosjPlacaKn = c(6359., 5418., 5170., 4892., 5348.), brojStanovnika = c(790017, 128384, 167121, 84104, 28434), prirez = c(18, 15, 10, 13, 10)) # pozovite funkciju `attach` i proslijedite podatkovni okvir `mjesto` kao parametar # ovo napravite samo jednom kako ne bi okvir ubacili više puta u stazu pretrage # ispišite stazu pretrage i komentirajte rezultat # ispišite varijablu pbr (bez reference na `mjesto`!) # promjenite treći element varijable prirez na 12 # ispišite tablicu `mjesto` # ispišite varijable globalne okoline # uz pomoć funkcije `detach` uklonite tablicu `mjesto` iz staze pretrage # pozovite funkciju `attach` i proslijedite podatkovni okvir `mjesto` kao parametar # ovo napravite samo jednom kako ne bi okvir ubacili više puta u stazu pretrage attach(mjesto) ## The following objects are masked _by_ .GlobalEnv: ## ## brojStanovnika, nazivMjesta, pbr, prirez, prosjPlacaKn # ispišite stazu pretrage i komentirajte rezultat search() cat(&quot;-------------------------\\n&quot;) # radi preglednijeg ispisa # ispišite varijablu pbr (bez reference na `mjesto`!) pbr cat(&quot;-------------------------\\n&quot;) # radi preglednijeg ispisa # promjenite treći element varijable prirez na 12 prirez[3] &lt;- 12 # ispišite tablicu `mjesto` mjesto cat(&quot;-------------------------\\n&quot;) # radi preglednijeg ispisa # ispišite varijable globalne okoline #ls() # probati na konzoli! # uz pomoć funkcije `detach` uklonite tablicu `mjesto` iz staze pretrage detach(mjesto) ## [1] &quot;.GlobalEnv&quot; &quot;mjesto&quot; &quot;package:corrplot&quot; ## [4] &quot;package:broom&quot; &quot;package:car&quot; &quot;package:carData&quot; ## [7] &quot;package:Hmisc&quot; &quot;package:Formula&quot; &quot;package:survival&quot; ## [10] &quot;package:lattice&quot; &quot;package:sn&quot; &quot;package:stats4&quot; ## [13] &quot;package:gridExtra&quot; &quot;package:RSQLite&quot; &quot;package:hflights&quot; ## [16] &quot;package:lubridate&quot; &quot;package:GGally&quot; &quot;package:forcats&quot; ## [19] &quot;package:stringr&quot; &quot;package:dplyr&quot; &quot;package:purrr&quot; ## [22] &quot;package:readr&quot; &quot;package:tidyr&quot; &quot;package:tibble&quot; ## [25] &quot;package:ggplot2&quot; &quot;package:tidyverse&quot; &quot;package:MASS&quot; ## [28] &quot;package:stats&quot; &quot;package:graphics&quot; &quot;package:grDevices&quot; ## [31] &quot;package:utils&quot; &quot;package:datasets&quot; &quot;package:methods&quot; ## [34] &quot;Autoloads&quot; &quot;package:base&quot; ## ------------------------- ## [1] 10000 51000 21000 31000 2000 ## ------------------------- ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 2000 Dubrovnik 5348 28434 10 ## ------------------------- Objasnimo što se dogodilo u gornjem primjeru. Uz pomoć funkcije attach podatkovni okvir mjesto postao je “mini-okolina”, tj. njegovi stupci postali su dostupni unutar staze pretrage. Očiti benefit ovoga jest to da ih možemo referencirati direktno, bez reference na originalni podatkovni okvir i operatora $. No ovaj naočigled praktičan trik ima skrivene zamke - prvo, ako se imena stupaca podudaraju sa postojećim varijablama globalne okoline, onda ti stupci neće biti vidljivi (o ovom ćemo biti obaviješteni adekvatnim upozorenjem). Drugo - i puno problematičnije - ako pokušamo mijenjati stupac okvira direktnim referenciranjem, R će to spriječiti i potiho će primijeniti copy-on-modify princip stvaranjem nove, globalne varijable koja će biti kopija referenciranog stupca. Neopreznom analitičaru tako može promaknuti činjenica da se promjene koje naizgled unosi uopće ne odražavaju na samom podatkovnom okviru, što može imati dalekosežne posljedice. Ovi potencijalni problemi su vrlo rašireni među početnicima u jeziku R tako da se u literaturi često može naći preporuka da se funkcija attach ne koristi ukoliko to iz nekog razloga nije nužno. Npr. Google-ov stilski vodič za R kaže “mogućnosti greške kod korištenja funkcije attach su brojne, zato ju izbjegavajte”. Još jedna mogućnost koju imamo jest korištenje funkcije with kojoj prvo dajemo referencu na okolinu, a potom izraz koji koristi varijable iz te okoline: with(mjesto, prosjPlacaKn[prirez &gt; 12]) no u većini slučajeva korištenje ove funkcije neće rezultirati čitljivom sintaksom već upravo naprotiv - programski kod se dodatno komplicira. Ukoliko želimo izbjeći stalno referenciranje podatkovnog okvira u izrazima, za to postoje novi paketi upravo namjenjenih lakom upravljanju podatkovnih okvirima uz pomoć čiste i pregledne sintakse, kao npr. dplyr ili tidyr. Ove pakete upoznati ćemo u jednoj od nastupajućih lekcija. Zadaci za vježbu Učitajte sljedeće pakete u radnu okolinu: magrittr, dplyr, tidyr, ggplot2. Ispišite stazu pretrage i provjerite gdje se nalaze učitani paketi. Sljedeća naredba stvoriti će vektor od 20 nasumično odabranih prirodnih brojeva od 1 do 100. Uz pomoć podsjetnika i/ili službene dokumentacije pronađite ugrađene funkcije koje izvršavaju zadane zadatke. # učitavamo 20 prirodnih brojeva od 1 do 100, sa ponavljanjem set.seed(1234) a &lt;- sample(1:100, 20, replace = T) ispišite: vektor a vrijednosti vektora a poredane obrnutim redoslijedom jedinstvene vrijednosti iz vektora a vrijednosti vektora a poredane uzlazno Spomenuli smo da su učitani paketi zapravo “okoline”. Ukoliko želimo dobiti direktnu referencu na njih, moramo se poslužiti funkcijom as.environment i imenom paketa. Pokušajte dobiti referencu na paket package:magrittr u obliku okoline te uz pomoć funkcije ls provjerite koje nazive ona sadrži u sebi. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "]
]
